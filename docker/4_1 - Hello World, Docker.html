<kendo-pdf-export _ngcontent-uvf-c168="" papersize="A4" margin="2cm" id="div-book-content" class="col-12 col-sm-10 offset-0 div-book-content" uipath_custom_id="10"><div><app-page-content _ngcontent-uvf-c168="" _nghost-uvf-c166="" class="font-size-14 font-size-sm-20"><div _ngcontent-uvf-c166="" class="mainContent mt-4"><div _ngcontent-uvf-c166="" id="bookContent" class="bookContent"><div _ngcontent-uvf-c166="" id="content"><div class="sect1" style="abcpdf-tag-visible: true" id="AU_2b260c26-14fe-44d6-a508-9d213ab764c5" uri="ImagesUri_../download/5c180f28-f752-47db-98e8-8656c84b148d/images/">
      <h1 class="title">Hello World, Docker</h1>
      <div class="sect2" id="refTitle0">
        <h2 class="title">1. Démarrage d’un conteneur simple </h2>
        <p class="defaut">Le sujet de l’installation de Docker étant
désormais traité, il est temps de commencer enfin à explorer
l’outil lui-même. Comme toute technologie informatique
qui se respecte, Docker dispose d’un exemple "Hello World", soit
dans notre cas un conteneur qui ne fait rien à part afficher
un message de bienvenue. L’intérêt de ce genre
d’approche&nbsp;est qu’il permet de valider que l’installation
du produit s’est bien passée, de vérifier que
l’ensemble de la chaîne logicielle fonctionne et de mettre
le pied à l’étrier pour l’utilisateur débutant.<var style="display:none"> Hello World</var></p>
        <p><span class="bridgehead_niv4">Démarrer un conteneur exemple
minimaliste</span></p>
        <pre class="literallayout"><code class="hljs">docker run hello-world<var style="display:none"> docker run</var></code></pre>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">Dorénavant et pour la suite
du livre, nous considérons que la gestion des droits est
traitée.&nbsp;Ainsi, s’il est nécessaire de
préfixer les commandes par le mot-clé <span class="courier11">sudo</span> sous Linux,&nbsp;nous ne
le montrerons plus dans les exemples. L’obtention d’un message comportant
le texte "permission denied" ou une expression approchante doit
donner le réflexe de rajouter&nbsp;le mot-clé si
nécessaire ou de traiter le problème de sécurité.
Dans le même souci de simplification, les exemples sont
montrés sur Linux.</p>
          </div>
        </div>
        <p class="defaut">Sauf problème d’installation de Docker
ou d’accès à Internet, l’affichage devrait être
le suivant&nbsp;:</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP01.png" title="images/03EP01.png" src="IMAGES/03EP01.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
        </div>
      </div>
      <div class="sect2" id="refTitle1">
        <h2 class="title">2. Détails des opérations effectuées</h2>
        <p class="defaut">Bien que l’exécution de la commande
ci-dessus soit très rapide, il s’est passé un certain
nombre d’opérations pour arriver à ce résultat.
C’est d’ailleurs la raison d’être de Docker&nbsp;que
de rendre disponible en une seule ligne de commande un enchaînement
d’opérations dont nous allons voir en les détaillant
ci-dessous qu’elles sont très variées.</p>
        <div class="sect3" id="refTitle2">
          <h3 class="title">a. Récupération d’une image</h3>
          <p class="defaut">Tout d’abord, Docker a besoin de lire l’image
nommée <span class="courier11">hello-world</span> qui
lui a été passée en paramètre
de la commande <span class="courier11">run</span>.</p>
          <p class="defaut">Comme nous l’avions rapidement abordé dans
l’introduction, Docker dispose d’un dépôt&nbsp;d’images
auxquelles il peut accéder par Internet. Ce dépôt,
accessible par l’URL <a class="url" href="https://registry.hub.docker.com" target="_blank">https://registry.hub.docker.com</a>,
regroupe toutes les images "officielles" fournies par Docker. Comme
il s’agit du registre d’images Docker utilisé par défaut,
il est souvent désigné simplement comme "le registre",
mais nous verrons un peu plus loin qu’il est possible de créer
d’autres registres.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Le registre par défaut est évidemment
public, de façon que la commande ci-dessus soit la plus
simple possible et n’ait pas à être alourdie par
des informations d’authentification. D’autres registres peuvent être
privés et réservés à telle ou
telle organisation, voire hybrider ce mode d’accessibilité avec
certaines ressources publiques et d’autres protégées.</p>
            </div>
          </div>
          <p class="defaut">Constatant que l’image n’était pas
déjà présente sur la machine hôte,
Docker l’a téléchargée. Il est toutefois
possible de récupérer l’image au préalable.</p>
          <p><span class="bridgehead_niv4">Télécharger une image
sans la lancer</span></p>
          <pre class="programlisting"><code class="hljs">docker pull hello-world</code></pre>
          <p class="defaut">Dans le cas de l’image <span class="courier11">hello-world</span>,
qui pèse moins d’1&nbsp;ko, la différence
de temps est infime, mais pour des images plus volumineuses, il
peut être particulièrement utile de séparer
le téléchargement et le lancement. Dans tous les cas,
l’image ne sera chargée qu’une seule fois. En effet, Docker
gère un cache des images sur la machine, et le prochain&nbsp;démarrage
d’une instance de conteneur sur la même image n’aboutira
donc pas nécessairement au rechargement de celle-ci, sauf
bien sûr si une instruction est fournie pour que Docker
aille vérifier que la nouvelle version n’a pas changé.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Une bonne pratique est de gérer
des versions immuables des images Docker, c’est-à-dire
que si une image a été publiée avec une
version donnée et que des modifications ont été réalisées,
il faut que la version augmente, de façon à signifier
aux consommateurs cette modification. Dans le cas contraire, en
ce qui concerne Docker, le client considérera qu’il possède
déjà la version dans son cache et n’ira pas vérifier
si la version sur le registre est différente, à moins qu’on
lui demande explicitement de la recharger.</p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle3">
          <h3 class="title">b. Identité de l’image</h3>
          <p class="defaut">Une recherche sur le registre Docker permet
de localiser la définition de l’image&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP02.png" title="images/03EP02.png" src="IMAGES/03EP02.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Dès l’affichage lié à la
recherche, on constate que les images peuvent supporter plusieurs&nbsp;architectures
informatiques et qu’<span class="courier11">hello-world</span> en
supporte justement un grand nombre. Il se trouve que cette image
est disponible sur des plateformes Linux et Windows, mais aussi
sur des systèmes MIPS 64, ARM, PowerPC, et même
pour des mainframes IBM Z. Dans la ligne de commande lancée
plus haut, la plateforme n’a pas eu besoin d’être précisée,
car le démon Docker est capable, de lui-même,
de négocier la bonne image avec le registre, et une erreur
est remontée si l’image ne supporte pas la plateforme installée.</p>
          <p class="defaut">Un clic sur la première entrée
de la liste ci-dessus, qui correspond à l’image cherchée,
montre plus de détails sur cette image. Le premier onglet
d’information, nommé <b>Description</b>,&nbsp;expose
en particulier ce qui s’appelle les tags, ou étiquettes
en français.</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP03.png" title="images/03EP03.png" src="IMAGES/03EP03.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Bien qu’il y ait nécessairement un
lien entre les différentes images et les différentes
plateformes, une image étiquetée Linux étant
prévue pour une plateforme Linux, il s’agit bien de deux
notions séparées. Par exemple, il est habituel
que des images pensées&nbsp;pour la plateforme Linux
soient pour certaines basées sur une version de Linux&nbsp;très
complète comme une Ubuntu et pour certaines sur une image
réduite comme une Alpine. La plateforme est alors toujours
Linux, mais les étiquettes permettront de faire la différence entre
les deux images.</p>
          <p class="defaut">Lorsque l’étiquette pointe sur une
seule image et que seul le choix de la plateforme sous-jacente reste à réaliser
par le moteur Docker lors du téléchargement, on
parle d’étiquette simple (<b>Simple Tags</b> dans
l’interface en anglais), mais pour complexifier la compréhension - bien
que cela simplifie au final les manipulations -, il existe
des étiquettes partagées (<b>Shared Tags</b>)
dont l’usage fait que le moteur Docker choisit non seulement la
plateforme d’exécution, mais aussi négocie l’image
même qui va être déployée. Dans
l’écran plus haut, on voit que l’étiquette <span class="courier11">latest</span> est dite partagée,
car son usage fera que le moteur Docker choisit entre deux images, à savoir
l’image prévue pour Linux et l’image prévue pour
Windows Nano Server. Bien sûr, il se trouve que la première
fonctionnera sur des plateformes Linux et la seconde&nbsp;sur
des plateformes Windows, mais les deux notions restent bien différentes.</p>
          <p class="defaut">Comme expliqué plus haut, on peut
avoir des images Linux très différentes en nombre
de fonctionnalités (et donc en taille) et il en va de même
pour Windows où, au lieu d’un Nano Server, une image pourrait
se baser sur une version Windows Server complète, avec
une image bien plus lourde en conséquence.</p>
          <p class="defaut">Dans notre cas, la commande ayant été lancée
sans préciser d’étiquette, c’est l’étiquette&nbsp;<span class="courier11">latest</span> qui est appelée par
défaut (comportement standard de Docker dans son échange
avec les registres). Cette étiquette donne le choix entre
une image <span class="courier11">nanoserver-1809</span>, qui supporte
la plateforme Windows, et une image <span class="courier11">linux</span>,
qui supporte toutes les autres plateformes.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Les images étant versionnées,
comme expliqué plus haut, nous reviendrons sur cette étiquette <span class="courier11">latest</span> bien particulière,
qui permet également de choisir une version de référence&nbsp;(et
non la plus récente, comme la traduction française de <span class="courier11">latest</span> pourrait le faire croire).</p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle4">
          <h3 class="title">c. Taille des images</h3>
          <p class="defaut">En accédant à l’onglet <b>Tags</b> de l’interface, on obtient une
description plus précise des étiquettes, qui devrait
permettre d’aider à la compréhension de cette notion
qui n’est pas évidente en première utilisation&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP04.png" title="images/03EP04.png" src="IMAGES/03EP04.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">On voit tout d’abord qu’il existe bel et bien
deux images simples, à savoir <span class="courier11">linux</span> et <span class="courier11">nanoserver</span>-1809, avec des tailles
extrêmement différentes. La seconde, comme on
peut le voir en bas de la capture d’écran, ne supporte
qu’une seule plateforme, à savoir <span class="courier11">windows/amd64</span>,
sur laquelle elle pèse 96&nbsp;Mo environ. La première,
plus bas dans la liste et non visible sur la capture ci-dessus, supporte
huit plateformes matérielles, et pèse quelques
ko sur chaque, avec des variations très légères.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Cette énorme différence
de poids s’explique par deux raisons. La première est que
Docker est une technologie pensée pour Linux et à laquelle
Windows s’adapte sans avoir les caractéristiques prévues
spécifiquement pour dans son architecture. Une image Windows,
au lieu de s’appuyer simplement sur le système sous-jacent,
doit embarquer un mini-système Windows pour être
réellement autonome. Dans ces conditions, passer sous la
barre des 100&nbsp;Mo est déjà un exploit
et rapproche ces images des poids standards d’images Docker pour
Linux avec des serveurs complexes, ou embarquant des systèmes
plus complets comme une image Ubuntu. Il y a toutefois une seconde
part d’explication à la différence de taille&nbsp;:
pour cette image particulière, les concepteurs sont partis
de zéro et n’incluent dans l’image qu’un exécutable
compilé nativement dans chacun des systèmes ciblés,
ce qui fait naturellement que le poids est réduit à l’extrême,
seul le binaire exécutable étant alors nécessaire. Nous
verrons dans la section suivante comment ceci est mis en œuvre.</p>
            </div>
          </div>
          <p class="defaut">L’interface plus haut est également
l’occasion de revenir sur la notion d’étiquette partagée
et de montrer justement l’étiquette <span class="courier11">latest</span>,
tout en haut de la liste, et qui couvre quant à elle neuf
plateformes, à savoir les huit de l’image <span class="courier11">linux</span> et la plateforme supplémentaire
de l’image <span class="courier11">nanoserver-1809</span>. On comprend
ainsi mieux l’effet&nbsp;"chapeau" de ces étiquettes
partagées, qui permettent à l’utilisateur de ne
pas se poser de questions et de demander à Docker de se
débrouiller pour récupérer une image
qui fonctionne sur son système et sa plateforme. Dans le
cas de <span class="courier11">latest</span>, le principe est aussi
de laisser Docker s’occuper de choisir la bonne version, le cas échéant.
Il se trouve que pour l’image <span class="courier11">hello-world</span>,
il n’y a qu’une version, donc ceci n’est pas visible. Mais pour
des images de serveurs logiciels, nous reviendrons plus loin sur
l’association entre <span class="courier11">latest</span> et la
dernière version stable de l’application, qui est une convention
dans l’écosystème Docker.</p>
          <p class="defaut">On remarque aussi que les tailles sont exactement
les mêmes entre les différentes plateformes des étiquettes
simples et de l’étiquette partagée, les étiquettes
n’étant en fait que des pointeurs sur les images au sens
binaire, qui possèdent un contenu et donc un poids associé.</p>
        </div>
        <div class="sect3" id="refTitle5">
          <h3 class="title">d. Anatomie de l’image Linux</h3>
          <p class="defaut">L’onglet <b>Description</b> de
l’interface Docker Hub donne une autre information intéressante
pour comprendre le fonctionnement de cette image <span class="courier11">hello-world</span>, à savoir le
lien vers le dépôt GitHub du code source de génération
de cette image, en l’occurrence <a class="url" href="https://github.com/docker-library/hello-world" target="_blank">https://github.com/docker-library/hello-world</a>&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP05.png" title="images/03EP05.png" src="IMAGES/03EP05.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Comme indiqué plus haut, nous allons
revenir dans cette section sur la raison du poids extrêmement
réduit de l’image <span class="courier11">hello-world</span> dans
son étiquette <span class="courier11">linux</span>. Contrairement à de
nombreuses images Docker qui contiennent non seulement une application
serveur mais aussi les dépendances nécessaires
en termes de système Linux,&nbsp;cette image part d’une
base complètement vide, et n’ajoute qu’un binaire exécutable
sans aucune autre dépendance sur la plateforme ciblée.</p>
          <p class="defaut">En anticipant un peu sur la suite du livre,
une image Docker est en général générée à partir
d’une description contenue dans un fichier <span class="courier11">Dockerfile</span>.
Pour la plateforme <span class="courier11">amd64</span> (qui correspond
en gros à un PC 64 bits), on peut ainsi trouver le fichier <span class="courier11">Dockerfile</span>&nbsp;dans <span class="courier11">amd64/hello-world</span> sur le
dépôt GitHub&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP06.png" title="images/03EP06.png" src="IMAGES/03EP06.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">En accédant à ce fichier,
on se rend compte qu’il est extrêmement réduit
en taille&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP07.png" title="images/03EP07.png" src="IMAGES/03EP07.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">La première des lignes de code concrétise
l’explication précédente d’une image de base réduite à zéro.
Encore une fois, nous anticipons un peu sur la suite, mais l’instruction <span class="courier11">FROM</span> permet de spécifier
dans un <span class="courier11">Dockerfile</span> à partir
de quelle image de base l’image courante va être construite,
et il se trouve que la valeur <span class="courier11">scratch</span> est
une valeur&nbsp;spéciale signifiant qu’il n’y a justement
pas d’image de base. Ainsi, le processus qui tournera dans le conteneur
Docker sera simplement exécuté sur le système
sous-jacent, sans aucune dépendance ni librairie lui permettant
de se trouver sur un système&nbsp;connu.</p>
          <p class="defaut">Pour cela, il faut que le contenu soit directement
exécutable sur la plateforme. Le fichier&nbsp;<span class="courier11">hello</span> qui est recopié par
l’opération <span class="courier11">COPY</span> et qui
est celui qui sera démarré lors de l’instanciation
d’un conteneur à partir de cette image (mot-clé <span class="courier11">CMD</span>) est donc un binaire exécutable
directement sur la plateforme Linux. En revenant sur la liste des
fichiers GitHub, on voit que ce fichier est disponible au même
endroit que le fichier <span class="courier11">Dockerfile</span>&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP08.png" title="images/03EP08.png" src="IMAGES/03EP08.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Et si on clique dessus, l’affichage montre
qu’il ne s’agit pas d’un script, mais bel et bien d’un binaire.
Il faut redescendre à la racine du dépôt
et fouiller dans les fichiers de build pour voir qu’une étape
de la compilation de cette image Docker consiste à générer
le fichier binaire à l’aide de l’utilitaire <span class="courier11">make</span>, le fichier <span class="courier11">Makefile</span> référençant à son
tour un fichier <span class="courier11">hello.c</span>&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP09.png" title="images/03EP09.png" src="IMAGES/03EP09.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Le jeu de piste s’arrête alors à ce
fichier <span class="courier11">hello.c</span>, qui contient le
code source à compiler pour, de manière générique
sur toutes les plateformes Linux, afficher le message que nous avons
vu lors de l’exécution du conteneur <span class="courier11">hello-world</span> plus
haut.</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP10.png" title="images/03EP10.png" src="IMAGES/03EP10.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Les seules dépendances sont les appels
système, en l’occurrence simplement <span class="courier11">SYS_write</span> qui
affiche un contenu texte, ce qui fait que l’exécutable
généré fonctionnera sur n’importe quelle
plateforme utilisant l’architecture <span class="courier11">amd64</span>.</p>
        </div>
        <div class="sect3" id="refTitle6">
          <h3 class="title">e. Anatomie de l’image Windows</h3>
          <p class="defaut">L’image pour Windows étant elle aussi
prévue pour une architecture <span class="courier11">amd64</span>, mais
ayant été rajoutée plus tard, elle se
trouve dans un sous-répertoire <span class="courier11">nanoserver-1809</span> du
précédent répertoire&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP11.png" title="images/03EP11.png" src="IMAGES/03EP11.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">L’image pour Windows n’a rien à voir
dans son fonctionnement avec celle prévue pour Linux. Au
lieu de générer un exécutable binaire,
l’image lance simplement un shell avec l’instruction <span class="courier11">cmd</span>, en lui passant la ligne de commande à exécuter
composée de <span class="courier11">type</span> suivi
d’un fichier. Le comportement de cette commande est tout simplement
d’afficher le contenu du fichier (l’équivalent de la commande <span class="courier11">cat</span> sous Linux)&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP12.png" title="images/03EP12.png" src="IMAGES/03EP12.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Le fichier <span class="courier11">hello.txt</span> était
auparavant copié depuis le code source, et on peut effectivement
retrouver son contenu au même niveau que le <span class="courier11">Dockerfile</span>&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP13.png" title="images/03EP13.png" src="IMAGES/03EP13.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
        </div>
        <div class="sect3" id="refTitle7">
          <h3 class="title">f. Lancement du processus</h3>
          <p class="defaut">Une fois l’image téléchargée
dans le cache local, la commande <span class="courier11">docker
run</span> va passer à une étape complètement
différente, qui n’a plus de lien avec l’extérieur
et le registre d’images Docker, mais travaille au contraire très
localement, en profondeur sur le système&nbsp;d’exploitation.</p>
          <p class="defaut">Un namespace va être créé sous
Linux, permettant de simuler un véritable sous-système&nbsp;avec
ce qui apparaît comme étant ses propres ressources,
son propre système de fichiers, etc., mais qui ne sont
en fait que des portions de ressources bien séparées
du système hôte. Les controlgroups Linux, qui
ont été expliqués dans le premier chapitre,&nbsp;se
chargent de régler les accès à ces ressources
de façon que le processus soit au maximum étanche
du reste.</p>
          <p class="defaut">L’instanciation se poursuit par le montage
d’un système de fichiers en couches (comme nous l’avons
expliqué dans l’introduction), de façon que le
conteneur final dispose des fichiers contenus dans l’image, mais
en ajoutant également une dernière couche qui
est la seule en écriture. Si des modifications sont apportées
dans le système de fichiers par le processus hébergé dans
le conteneur, c’est cette couche qui sera modifiée&nbsp;en
fonction.</p>
          <p class="defaut">Dans notre exemple <span class="courier11">hello-world</span>,
aucune écriture n’est réalisée, mais
la couche existe tout de même&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP14.png" title="images/03EP14.png" src="IMAGES/03EP14.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">La couche <span class="courier11">scratch</span> est
en fait inexistante, car il s’agit - comme expliqué plus haut - d’un
identifiant particulier précisant que l’image ne se base
sur aucune autre image existante.</p>
          <p class="defaut">Docker procède également à la
création d’une interface réseau qui permettra la
communication&nbsp;entre le conteneur et la machine hôte.
Dans le cas présent, le conteneur sera donc associé à une
adresse IP particulière mais il se trouve que cela ne servira
pas, car aucun port n’est exposé par le processus lancé localement.
Toutefois, Docker ne pouvant pas le savoir, les ressources seront
tout de même créées. Enfin, le conteneur
est pointé sur le sous-système de fichiers en
utilisant la commande <span class="courier11">chroot</span> et
peut passer à la dernière étape, à savoir le
lancement du processus proprement dit.</p>
        </div>
        <div class="sect3" id="refTitle8">
          <h3 class="title">g. Exécution du processus dans un conteneur</h3>
          <p class="defaut">Le sous-système étant généré,
le processus désigné par l’instruction <span class="courier11">CMD</span> du <span class="courier11">Dockerfile</span>&nbsp;à l’origine
de l’image sera ensuite lancé à l’intérieur
de cette zone étanche. Dans le cas de Linux, l’appel système <span class="courier11">SYS_write</span> est ainsi exécuté,
qui affiche&nbsp;le message contenu dans le binaire, puis le
programme termine en renvoyant un code 0, signe de fin normale.</p>
          <p class="defaut">Comme le processus se termine, le moteur Docker
reprend la main et place à son tour le conteneur dans un état
de fin. Par défaut, le conteneur n’est pas effacé,
car Docker le tient à disposition pour analyse des logs,
par exemple.</p>
        </div>
        <div class="sect3" id="refTitle9">
          <h3 class="title">h. Opérations suivant l’exécution</h3>
          <p class="defaut">L’image <span class="courier11">hello-world</span> contient
un processus prévu pour réaliser une tâche - en
l’occurrence&nbsp;afficher un message de bienvenue - puis
s’arrêter. En théorie, nous pourrions&nbsp;donc
suivre le processus par la commande ci-dessous.</p>
          <p><span class="bridgehead_niv4">Lister les conteneurs en cours</span></p>
          <pre class="programlisting"><code class="hljs">docker ps<var style="display:none"> docker ps</var></code></pre>
          <p class="defaut">En pratique, le conteneur <span class="courier11">hello-world</span> n’étant
pas lancé en arrière-plan, la commande <span class="courier11">run</span> ne rendra la main que lorsque
le processus est terminé, donc il est impossible de lancer
la commande pendant que le conteneur s’exécute. D’ailleurs,
même si le conteneur avait été lancé dans
ce mode, l’exécution du processus est tellement rapide&nbsp;qu’il
aurait rendu la main bien avant que nous puissions entrer la commande.</p>
          <p class="defaut">Heureusement, il est possible de retrouver
la trace des conteneurs exécutés même
après que ceux-ci se sont arrêtés. C’est
tout l’intérêt justement du fait que Docker garde
le conteneur une fois que le processus qui s’exécutait
dedans a rendu la main.</p>
          <p><span class="bridgehead_niv4">Lister tous les conteneurs</span></p>
          <pre class="literallayout"><code class="hljs">docker ps -a</code></pre>
          <p class="defaut">La commande ci-dessus aboutit à un
affichage comme suit&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP15.png" title="images/03EP15.png" src="IMAGES/03EP15.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">La mise en page ne permet pas de le voir facilement,
mais il s’agit de deux lignes, dont la première fournit
les titres correspondant aux valeurs de la deuxième. Reprenons
les différentes informations&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1"><span class="courier11">CONTAINER
ID</span> (<span class="courier11">a3fcdbe31834</span>)&nbsp;:
il s’agit de l’identifiant unique du conteneur. Docker crée
automatiquement un nouvel identifiant à chaque lancement
d’un conteneur, même s’ils instancient la même
image. Cet identifiant peut être fourni, y compris dans
sa forme réduite (les quatre ou cinq premiers caractères
suffisent en général), lorsqu’on souhaite mettre
en pause ou arrêter un conteneur.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">IMAGE</span> (<span class="courier11">hello-world</span>)&nbsp;: il s’agit
du nom de l’image utilisée pour instancier le conteneur.
Si aucun suffixe n’est précisé, il s’agit de l’étiquette <span class="courier11">latest</span>.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">COMMAND</span> ("<span class="courier11">/hello</span>")&nbsp;: cette
information reprend le contenu de la ligne <span class="courier11">CMD</span> du
fichier&nbsp;<span class="courier11">Dockerfile</span>, donc
la commande lançant le processus dans le conteneur.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">CREATED</span> (<span class="courier11">5 hours ago</span>)&nbsp;: donne la date
d’initialisation du conteneur.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">STATUS</span> (<span class="courier11">Exited (0) 5 hours ago</span>)&nbsp;:
le statut du conteneur contient plusieurs informations. Dans notre
cas, comme dit précédemment, le conteneur s’est
arrêté, et le processus interne est sorti avec
le code 0, qui correspond par convention à un déroulement
sans erreur. L’arrêt du processus a eu lieu au moment exposé.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">PORTS&nbsp;</span>:
les ports réseau exposés par le conteneur, en
l’occurrence aucun dans le cas de ce simple exemple n’affichant
que du texte. Nous reviendrons bien sûr abondamment sur
des cas plus complexes de serveur exposant des fonctionnalités
sur des ports, en montrant comment Docker les gère.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">NAMES</span> (<span class="courier11">quizzical_spence</span>)&nbsp;:
il est possible d’affecter un nom à un conteneur lors de
son lancement, pour pouvoir les manipuler plus facilement que par
leur identifiant. En l’absence de nom spécifié,
Docker crée un nom à partir d’une combinaison
de noms propres et d’adjectifs, ce qui représente déjà un
progrès dans la lisibilité si on le compare à l’identifiant
technique <span class="courier11">a3fcdbe31834</span>.</p>
              </li>
            </ul>
          </div>
          <p class="defaut">Un autre signe de l’exécution du
conteneur est que l’image <span class="courier11">hello-world</span> a été téléchargée,
et se retrouve donc dans la liste des images présentes
sur la machine hôte.</p>
          <p><span class="bridgehead_niv4">Lister les images</span></p>
          <pre class="literallayout"><code class="hljs">docker images<var style="display:none"> docker images</var></code></pre>
          <p class="defaut">Le résultat sera quelque chose comme&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP16.png" title="images/03EP16.png" src="IMAGES/03EP16.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Là encore, une ligne de titre et
une seule ligne de données sont affichées pour l’instant,
et qui se lisent comme suit&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1"><span class="courier11">REPOSITORY</span> (<span class="courier11">hello-world</span>)&nbsp;: le nom de
l’image dans le dépôt.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">TAG</span> (<span class="courier11">latest</span>)&nbsp;: sa version, qui
peut être un nombre ou une dénomination textuelle.&nbsp;Nous
verrons un peu plus loin que ces tags peuvent être multiples par
rapport à une même image.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">IMAGE ID</span> (<span class="courier11">bf756fb1ae65</span>)&nbsp;: un identifiant
unique pour l’image.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">CREATED</span> (<span class="courier11">8 months ago</span>)&nbsp;: la date de
création de l’image dans la machine hôte de Docker.
Attention, il ne s’agit pas de la date de création de l’image par
le dépôt, mais bien de celle de la création
du cache localement.</p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">VIRTUAL
SIZE</span> (<span class="courier11">13.3&nbsp;kB</span>)&nbsp;:
la taille de l’image. Il s’agit d’une taille virtuelle représentant
toutes les couches composant successivement l’image. La taille réellement
occupée sur le disque dur par une image est donc souvent
bien inférieure. Dans notre cas, la couche <span class="courier11">hello-world</span> ne pèse que 13,3&nbsp;ko,
et il s’agit de plus de sa taille effective, car elle ne se base
pas sur une couche inférieure.</p>
              </li>
            </ul>
          </div>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Par contre, cette taille est différente
de celle affichée sur la page du Docker Hub, mais en regardant
attentivement sur la capture plus haut, on s’aperçoit qu’il
s’agissait de la taille compressée. Pour économiser
de la bande passante, les images sont en effet compressées
sur le Docker Hub et décompressées localement,
avec un système de condensat SHA permettant de vérifier
que le contenu est bien strictement le même à l’arrivée
qu’au départ.</p>
            </div>
          </div>
          <p class="defaut">La commande ci-dessous permet d’obtenir plus
d’informations sur l’image voulue. On pourra en particulier retrouver
la date exacte de création de cette image (en bas de la
capture)&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/03EP17.png" title="images/03EP17.png" src="IMAGES/03EP17.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmO5hzk9y7jYiAs%3d"></div>
          </div>
          <p class="defaut">Ce premier exemple de lancement d’un conteneur
nous a permis de montrer les commandes&nbsp;de base de Docker.
La suite va avancer un peu plus loin dans les manipulations de Docker,
sans toutefois s’aventurer pour l’instant dans des opérations
complexes.</p>
        </div>
      </div>
    </div></div></div></div></app-page-content><!----><!----><!----></div></kendo-pdf-export>