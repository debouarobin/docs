<kendo-pdf-export _ngcontent-uvf-c168="" papersize="A4" margin="2cm" id="div-book-content" class="col-12 col-sm-10 offset-0 div-book-content" uipath_custom_id="10"><div><app-page-content _ngcontent-uvf-c168="" _nghost-uvf-c166="" class="font-size-14 font-size-sm-20"><div _ngcontent-uvf-c166="" class="mainContent mt-4"><div _ngcontent-uvf-c166="" id="bookContent" class="bookContent"><div _ngcontent-uvf-c166="" id="content"><div class="sect1" style="abcpdf-tag-visible: true" id="AU_6c740d3e-867f-4f8f-a8a7-3af1a30ec57f" uri="ImagesUri_../download/5c180f28-f752-47db-98e8-8656c84b148d/images/">
      <h1 class="title">Exploitation d’une infrastructure Docker</h1>
      <div class="sect2" id="refTitle0">
        <h2 class="title">1. Le réseau dans Docker<var style="display:none"> Réseau</var></h2>
        <p class="defaut">Nous avons à plusieurs reprises utilisé des
fonctionnalités réseau des conteneurs sans nous
en rendre compte, lors des mises en pratique précédentes. C’est
un signe positif sur le fait que Docker rend assez transparente
la gestion du réseau, mais il convient d’approfondir légèrement
le sujet, de façon à ouvrir les autres possibilités.
Le but de la présente section n’est pas de rentrer dans toutes
les subtilités de la gestion réseau de Docker
(il faudrait pour cela un livre entier), mais d’expliquer comment
les manipulations réalisées précédemment
fonctionnent et de montrer que le réseau peut être
configuré autrement si besoin.</p>
        <div class="sect3" id="refTitle1">
          <h3 class="title">a. Mode de fonctionnement standard (bridge)<var style="display:none"> Bridge</var></h3>
          <p class="defaut">De façon à simuler une réelle
machine étanche, les conteneurs possèdent leur propre
interface réseau (nous verrons quelques exceptions un peu
plus loin). Par défaut, Docker&nbsp;fonctionne en mode
dit bridge (pont, en anglais), à savoir que le démon
Docker&nbsp;établit une couche d’indirection entre
l’interface réseau de la machine hôte et celle
créée pour les conteneurs. Cette interface réseau intermédiaire
s’appelle <span class="courier11">docker0</span>.&nbsp;</p>
          <p class="defaut">La commande <span class="courier11">ifconfig</span> exécutée
sur une machine sur laquelle Docker est installé montre
les caractéristiques de cette interface, en plus des traditionnelles
interfaces réseau&nbsp;Ethernet <span class="courier11">eth0</span> et
boucle locale <span class="courier11">lo</span>&nbsp;:</p>
          <pre class="programlisting"><code class="hljs delphi">jpg@Ubuntu1410:~$ ifconfig&nbsp;
docker0&nbsp;&nbsp; Link encap:Ethernet&nbsp;&nbsp;HWaddr <span class="hljs-number">56</span>:<span class="hljs-number">84</span>:<span class="hljs-number">7</span>a:fe:<span class="hljs-number">97</span>:<span class="hljs-number">99</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet &nbsp;
adr:<span class="hljs-number">172.17</span>.<span class="hljs-number">42.1</span>&nbsp;&nbsp;Bcast:<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>&nbsp;&nbsp;Masque:<span class="hljs-number">255.255</span>.<span class="hljs-number">0.0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adr inet6: fe80::<span class="hljs-number">5484</span>:<span class="hljs-number">7</span>aff:fefe:<span class="hljs-number">9799</span>/<span class="hljs-number">64</span> Scope:Lien&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST MULTICAST&nbsp;&nbsp;MTU:<span class="hljs-number">1500</span>&nbsp;&nbsp;Metric:<span class="hljs-number">1</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packets reçus:<span class="hljs-number">2378</span> erreurs:<span class="hljs-number">0</span>&nbsp;:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> frame:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:<span class="hljs-number">3520</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> &nbsp;
carrier:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:<span class="hljs-number">0</span> lg <span class="hljs-keyword">file</span> transmission:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Octets reçus:<span class="hljs-number">150825</span> (<span class="hljs-number">150.8</span> KB) Octets transmis:<span class="hljs-number">3449866</span> &nbsp;
(<span class="hljs-number">3.4</span> MB)&nbsp;
&nbsp;
eth0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Ethernet&nbsp;&nbsp;HWaddr <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">8</span>f:<span class="hljs-number">5</span>b:<span class="hljs-number">2</span>c&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet &nbsp;
adr:<span class="hljs-number">10.0</span>.<span class="hljs-number">2.15</span>&nbsp;&nbsp;Bcast:<span class="hljs-number">10.0</span>.<span class="hljs-number">2.255</span>&nbsp;&nbsp;Masque:<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adr inet6: fe80::a00:<span class="hljs-number">27</span>ff:fe8f:<span class="hljs-number">5</span>b2c/<span class="hljs-number">64</span> Scope:Lien&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST RUNNING MULTICAST&nbsp;&nbsp;MTU:<span class="hljs-number">1500</span>&nbsp;&nbsp;Metric:<span class="hljs-number">1</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packets reçus:<span class="hljs-number">431534</span> erreurs:<span class="hljs-number">0</span>&nbsp;:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> frame:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:<span class="hljs-number">1264210</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> &nbsp;
carrier:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:<span class="hljs-number">0</span> lg <span class="hljs-keyword">file</span> transmission:<span class="hljs-number">1000</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Octets reçus:<span class="hljs-number">381926087</span> (<span class="hljs-number">381.9</span> MB) Octets &nbsp;
transmis:<span class="hljs-number">2786326446</span> (<span class="hljs-number">2.7</span> GB)&nbsp;
&nbsp;
lo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Boucle locale&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet adr:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>&nbsp;&nbsp;Masque:<span class="hljs-number">255.0</span>.<span class="hljs-number">0.0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adr inet6:&nbsp;::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> Scope:Hôte&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP LOOPBACK RUNNING&nbsp;&nbsp;MTU:<span class="hljs-number">65536</span>&nbsp;&nbsp;Metric:<span class="hljs-number">1</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packets reçus:<span class="hljs-number">8475</span> erreurs:<span class="hljs-number">0</span>&nbsp;:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> frame:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:<span class="hljs-number">8475</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> &nbsp;
carrier:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:<span class="hljs-number">0</span> lg <span class="hljs-keyword">file</span> transmission:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Octets reçus:<span class="hljs-number">953749</span> (<span class="hljs-number">953.7</span> KB) Octets transmis:<span class="hljs-number">953749</span> &nbsp;
(<span class="hljs-number">953.7</span> KB)</code></pre>
          <p class="defaut">La même commande lancée
depuis un conteneur créé ponctuellement, juste
le temps de lancer la même commande (grâce à l’option <span class="courier11">--rm</span>, qui supprime le conteneur en
sortie), montre la sortie suivante&nbsp;:</p>
          <pre class="programlisting"><code class="hljs typescript">jpg<span class="hljs-meta">@Ubuntu1410</span>:~$ docker run --rm ubuntu:trusty ifconfig&nbsp;
eth0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Ethernet&nbsp;&nbsp;HWaddr <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:ac:<span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr:<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>&nbsp;&nbsp;Bcast:<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>&nbsp;&nbsp;Mask:<span class="hljs-number">255.255</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr: fe80::<span class="hljs-number">42</span>:acff:fe11:<span class="hljs-number">1</span>/<span class="hljs-number">64</span> Scope:Link&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST&nbsp;&nbsp;MTU:<span class="hljs-number">1500</span>&nbsp;&nbsp;Metric:<span class="hljs-number">1</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets:<span class="hljs-number">3</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> frame:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:<span class="hljs-number">1</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> carrier:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:<span class="hljs-number">0</span> txqueuelen:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes:<span class="hljs-number">270</span> (<span class="hljs-number">270.0</span> B)&nbsp;&nbsp;TX bytes:<span class="hljs-number">90</span> (<span class="hljs-number">90.0</span> B)&nbsp;
&nbsp;
lo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Local Loopback&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr:<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>&nbsp;&nbsp;Mask:<span class="hljs-number">255.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr:&nbsp;::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> Scope:Host&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP LOOPBACK RUNNING&nbsp;&nbsp;MTU:<span class="hljs-number">65536</span>&nbsp;&nbsp;Metric:<span class="hljs-number">1</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets:<span class="hljs-number">0</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> frame:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:<span class="hljs-number">0</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> carrier:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:<span class="hljs-number">0</span> txqueuelen:<span class="hljs-number">0</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes:<span class="hljs-number">0</span> (<span class="hljs-number">0.0</span> B)&nbsp;&nbsp;TX bytes:<span class="hljs-number">0</span> (<span class="hljs-number">0.0</span> B)</code></pre>
          <p class="defaut">À l’intérieur du conteneur,
on dispose donc bien d’une interface réseau, mais qui n’est
pas la même que celle disponible sur la machine hôte.
La base d’adresses est toutefois la même (127.17.0.0 avec
un masque 255.255.0.0).</p>
          <p class="defaut">Une représentation graphique montre
mieux l’empilement des interfaces réseau&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/05EP38.png" title="images/05EP38.png" src="IMAGES/05EP38.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmN7MPSmy7jYiAs%3d"></div>
          </div>
          <p class="defaut">La présence de ces couches séparées
permet de réaliser toutes les opérations de routage,
filtre, etc. en fonction des situations rencontrées. Par
défaut, Docker autorise les paquets à sortir sur
le réseau de la machine hôte, et la couche <span class="courier11">docker0</span> permet d’attribuer&nbsp;une
adresse IP à chacun des conteneurs dans une même
plage d’adresses. C’est cette couche intermédiaire qui
sert de support aux liens entre conteneurs démontrés&nbsp;dans
l’exemple plus haut dans le présent chapitre.</p>
          <p class="defaut">Le support réseau regorge d’options.
Nous n’en montrerons que trois qui sont parmi les plus souvent utilisées.
Tout d’abord, l’option <span class="courier11">--add-host</span> permet de
rajouter au lancement une entrée dans le fichier <span class="courier11">hosts</span> du conteneur, et donc de mettre
en lien un alias avec l’adresse de la machine ciblée. Par exemple&nbsp;:</p>
          <pre class="programlisting"><code class="hljs cs">jpg@Ubuntu1410:~$ docker run --rm --<span class="hljs-keyword">add</span>-host news:<span class="hljs-number">93.184</span><span class="hljs-number">.220</span><span class="hljs-number">.20</span>&nbsp;
ubuntu:<span class="hljs-function">trusty ping news&nbsp;
PING <span class="hljs-title">news</span> (<span class="hljs-params"><span class="hljs-number">93.184</span><span class="hljs-number">.220</span><span class="hljs-number">.20</span></span>) 56(<span class="hljs-params"><span class="hljs-number">84</span></span>) bytes of data.&nbsp;
64 bytes <span class="hljs-keyword">from</span> <span class="hljs-title">news</span> (<span class="hljs-params"><span class="hljs-number">93.184</span><span class="hljs-number">.220</span><span class="hljs-number">.20</span></span>): icmp_seq</span>=<span class="hljs-number">1</span> ttl=<span class="hljs-number">50</span> time=<span class="hljs-number">33.2</span> ms&nbsp;
<span class="hljs-number">64</span> <span class="hljs-function">bytes <span class="hljs-keyword">from</span> <span class="hljs-title">news</span> (<span class="hljs-params"><span class="hljs-number">93.184</span><span class="hljs-number">.220</span><span class="hljs-number">.20</span></span>): icmp_seq</span>=<span class="hljs-number">2</span> ttl=<span class="hljs-number">50</span> time=<span class="hljs-number">35.9</span> ms&nbsp;
^C&nbsp;
--- news ping statistics ---&nbsp;
<span class="hljs-number">2</span> packets transmitted, <span class="hljs-number">2</span> received, <span class="hljs-number">0</span>% packet loss, time <span class="hljs-number">1001</span>ms&nbsp;
rtt min/avg/max/mdev = <span class="hljs-number">33.292</span>/<span class="hljs-number">34.596</span>/<span class="hljs-number">35.901</span>/<span class="hljs-number">1.317</span> ms</code></pre>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Attention à ne pas surutiliser
cette option, par exemple pour mettre en œuvre des liens
entre les conteneurs. L’option <span class="courier11">--link</span> est
plus puissante car elle abstrait l’utilisateur de la connaissance
de l’adresse IP affectée. Il convient donc de n’utiliser
l’option <span class="courier11">--add-host</span> que pour des
machines externes.</p>
            </div>
          </div>
          <p class="defaut">Ensuite, l’option <span class="courier11">--dns</span> permet
de passer l’IP d’un serveur DNS au conteneur.</p>
          <p class="defaut">Enfin, l’option <span class="courier11">--hostname</span> est
utilisée pour changer le nom de machine correspondant au
conteneur.</p>
        </div>
        <div class="sect3" id="refTitle2">
          <h3 class="title">b. Modes de fonctionnement alternatifs</h3>
          <p class="defaut">Le mode bridge couvre quasiment tous les cas
d’usages standards et est relativement sécurisé,
dans le sens où, si vous n’utilisez pas l’option <span class="courier11">-p</span> pour associer un port disponible
par la machine hôte à un port exposé par
le conteneur, ceux-ci restent étanches. Il faut donc explicitement
exposer un conteneur à l’extérieur, ce qui est
une bonne chose.</p>
          <p class="defaut">Il existe toutefois quelques cas particuliers
dans lesquels le réseau doit être configuré différemment,
grâce à l’option <span class="courier11">--net</span> sur
la commande <span class="courier11">docker run</span>. À noter
que nous n’entrerons pas dans la complexité du paramétrage
réseau sur le démon Docker lui-même.</p>
          <p class="defaut">Un premier cas particulier est de rendre un
conteneur complètement étanche, à savoir
qu’il n’exposera pas de ports à la consommation, mais qu’il
ne pourra pas non plus appeler&nbsp;la pile réseau
de la machine hôte. Ce mode de fonctionnement est associé à la
valeur <span class="courier11">none</span> de l’option <span class="courier11">--net</span>&nbsp;:</p>
          <pre class="programlisting"><code class="hljs typescript">jpg<span class="hljs-meta">@Ubuntu1410</span>:~$ docker run --rm --net none ubuntu:trusty ping &nbsp;
lemonde.fr&nbsp;
ping: unknown host lemonde.fr</code></pre>
          <p class="defaut">Un second cas particulier est l’inverse du
premier et consiste à considérer le conteneur
comme un processus non étanchéifié et
qui aura les mêmes droits que les processus locaux de la
machine hôte au regard du réseau&nbsp;: son
adresse sera vue et accessible par l’extérieur (nonobstant
les règles de pare-feu). Ce mode de fonctionnement est
associé à la valeur <span class="courier11">host</span> de
l’option <span class="courier11">--net</span>.</p>
          <p class="defaut">Le diagramme d’interface est alors comme suit&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/05EP39.png" title="images/05EP39.png" src="IMAGES/05EP39.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmN7MPSmy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Enfin, un troisième cas, peut-être
encore plus particulier que les deux précédents,
correspond à la mise en commun de la couche réseau étanche
entre deux conteneurs, qu’on appelle alors des conteneurs joints.
Le diagramme est alors comme ceci&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/05EP40.png" title="images/05EP40.png" src="IMAGES/05EP40.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmN7MPSmy7jYiAs%3d"></div>
          </div>
          <p class="defaut">La mise en œuvre de ce mode de fonctionnement
est un peu différente des précédentes,
car il ne suffit pas de passer une valeur fixe à l’option <span class="courier11">--net</span>&nbsp;: il faut lui passer
le nom du premier conteneur avec lequel le second souhaite partager la
couche réseau. Les commandes suivantes montrent un exemple
avec un conteneur exposant un serveur&nbsp;web puis la constatation
de l’activité réseau par un autre conteneur partageant
la même pile réseau (entre les deux commandes,
démarrer un navigateur sur <span class="courier11">http://localhost:8080</span> pour
créer de l’activité)&nbsp;:</p>
          <pre class="programlisting"><code class="hljs delphi">jpg@Ubuntu1410:~$ docker run -d --<span class="hljs-keyword">name</span> conteneur2 -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> nginx&nbsp;
d3c6353f7a4acf82c02dbc8d404c8b9ad4292d3ce89fb7fcfc9ece3ca67b8c0b&nbsp;
&nbsp;
&nbsp;
[déclencher une activité réseau sur le premier conteneur]&nbsp;
&nbsp;
jpg@Ubuntu1410:~$ docker run --rm --<span class="hljs-keyword">name</span> conteneur3 --net 
container:conteneur2&nbsp;
ubuntu:trusty netstat -al&nbsp;
Active Internet connections (servers <span class="hljs-keyword">and</span> established)&nbsp;
Proto Recv-Q Send-Q <span class="hljs-keyword">Local</span> Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foreign Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State&nbsp;
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number">0</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number">0</span> *:http&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTEN&nbsp;
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number">0</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number">0</span> d3c6353f7a4a:http&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number">172.17</span>.<span class="hljs-number">42.1</span>:<span class="hljs-number">35156</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESTABLISHED&nbsp;
&nbsp;
Active UNIX domain sockets (servers <span class="hljs-keyword">and</span> established)&nbsp;
Proto RefCnt Flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">Type</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; State&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I-Node&nbsp;&nbsp; Path&nbsp;
unix&nbsp;&nbsp;<span class="hljs-number">3</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STREAM&nbsp;&nbsp;&nbsp;&nbsp; CONNECTED&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-number">23165</span>&nbsp;
unix&nbsp;&nbsp;<span class="hljs-number">3</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STREAM &nbsp; &nbsp; CONNECTED&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-number">23166</span></code></pre>
          <p class="defaut">Les usages de cette option sont limités à des
contextes où un conteneur doit pouvoir analyser la pile
réseau utilisée par l’autre. On peut imaginer
par exemple un conteneur dédié à la supervision
réseau ou bien un IDS (<span class="italic">Intrusion Detection System</span>,
système de détection&nbsp;d’intrusion réseau
en français, qui est un applicatif recherchant des traces
de comportements suspects dans les accès, afin d’améliorer
la sécurité d’un système).</p>
          <p class="defaut">Docker est encore jeune et il n’est pas impossible
que dans les années suivantes remontent&nbsp;des bonnes
pratiques qui augmentent l’utilisation de ces cas particuliers,
mais pour l’instant leur usage est anecdotique.</p>
        </div>
        <div class="sect3" id="refTitle3">
          <h3 class="title">c. Création dynamique de réseaux dédiés</h3>
          <p class="defaut">Dans l’exemple d’utilisation de Docker Compose
un peu plus haut, il a rapidement été expliqué qu’un
réseau dédié était généré lors
du lancement de la pile applicative. La présence de ce
réseau a ensuite été évoquée
comme solution permettant à chacun des conteneurs dans
l’application de se voir, tout en étant par défaut
invisibles de la machine&nbsp;locale, mais aussi des conteneurs
lancés sur une autre instance d’application pilotée
par Docker Compose.</p>
          <p class="defaut">La commande ci-dessous nous permet de voir
la liste des réseaux gérés par Docker,
et on retrouve en particulier celui qui a été créé dynamiquement
pour notre pile applicative Docker Compose, préfixé par
le nom du répertoire pour rendre plus simple de le distinguer
des autres&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/05EP41.png" title="images/05EP41.png" src="IMAGES/05EP41.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmN7MPSmy7jYiAs%3d"></div>
          </div>
          <p class="defaut">La commande <span class="courier11">docker
network inspect</span> permet de détailler les paramètres
de ce réseau&nbsp;:</p>
          <pre class="programlisting"><code class="hljs java">azureuser<span class="hljs-meta">@ClearDockerENI</span>~/middleoffice-microservices-v2 $ docker network&nbsp;
inspect middleoffice-microservices-v2_default&nbsp;
[&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Name"</span>: <span class="hljs-string">"middleoffice-microservices-v2_default"</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Id"</span>: &nbsp;
<span class="hljs-string">"d725004b8d835fb282e4c536af192d3d90ca7464b7b97b30ef31b97880f4b5b4"</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Created"</span>: <span class="hljs-string">"2020-10-04T14:40:52.916173945Z"</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Scope"</span>: <span class="hljs-string">"local"</span>,<b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Driver"</span>: <span class="hljs-string">"bridge"</span>,</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"EnableIPv6"</span>: <span class="hljs-keyword">false</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"IPAM"</span>: {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Driver"</span>: <span class="hljs-string">"default"</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Options"</span>: <span class="hljs-keyword">null</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Config"</span>: [&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Subnet"</span>: <span class="hljs-string">"172.22.0.0/16"</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Gateway"</span>: <span class="hljs-string">"172.22.0.1"</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Internal"</span>: <span class="hljs-keyword">false</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Attachable"</span>: <span class="hljs-keyword">true</span>,<b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Ingress"</span>: <span class="hljs-keyword">false</span>,</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"ConfigFrom"</span>: {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Network"</span>: <span class="hljs-string">""</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"ConfigOnly"</span>: <span class="hljs-keyword">false</span>,<b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Containers"</span>:</b>{&nbsp;
&nbsp;
<span class="hljs-string">"07ac5b446870d550eb4604ee5cd154e5b454d8ec7acfe1c9e8d4f261ad8d2f21"</span>: {&nbsp;<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Name"</span>: <span class="hljs-string">"mo-demandes-bo"</span>,</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"EndpointID"</span>: &nbsp;
<span class="hljs-string">"41c1e3aa35b8d75362f764f00beeb71d578a898fedab75e1e6223b9a883b277e"</span>&nbsp;
,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"MacAddress"</span>: <span class="hljs-string">"02:42:ac:16:00:05"</span>,<b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"IPv4Address"</span>: <span class="hljs-string">"172.22.0.5/16"</span>,</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"IPv6Address"</span>: <span class="hljs-string">""</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;
&nbsp;
(...)&nbsp;
&nbsp;
<span class="hljs-string">"f724bea2d843e0931ded2decd3a459fc10b6fb5c729fcfbc9a7c78fc2bdb1c39"</span>: {<b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Name"</span>: <span class="hljs-string">"mo-database"</span>,</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"EndpointID"</span>: &nbsp;
<span class="hljs-string">"8cf8be9d38bc76093f7638fbd78f0c587f0d47ef517597338eeb342bf22b0357"</span>&nbsp;
,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"MacAddress"</span>: <span class="hljs-string">"02:42:ac:16:00:04"</span>,<b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"IPv4Address"</span>: <span class="hljs-string">"172.22.0.4/16"</span>,</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"IPv6Address"</span>: <span class="hljs-string">""</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Options"</span>: {},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Labels"</span>: {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"com.docker.compose.network"</span>: <span class="hljs-string">"default"</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"com.docker.compose.project"</span>: <span class="hljs-string">"middleoffice-microservices-v2"</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"com.docker.compose.version"</span>: <span class="hljs-string">"1.24.1"</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
]</code></pre>
          <p class="defaut">C’est le driver <span class="courier11">brigde</span> qui
a été utilisé, mais il est possible de
mettre en place des réseaux&nbsp;de type <span class="courier11">overlay</span>, comme nous le verrons un
peu plus loin. Les conteneurs faisant partie du réseau
sont listés, avec leur nom mais aussi l’adresse IPv4 qui
leur est affectée dans ce réseau (la liste est
volontairement tronquée ci-dessus). Enfin, le mode de fonctionnement
Ingress est inactif par défaut. Dans notre exemple, cela
ne pose pas de problème, vu que nous confions cette responsabilité de
gestion des flux entrants&nbsp;depuis l’extérieur à Traefik.</p>
        </div>
        <div class="sect3" id="refTitle4">
          <h3 class="title">d. Support des liens entre conteneurs<var style="display:none"> Liens</var></h3>
          <p class="defaut">Le mécanisme de liens entre les conteneurs
a été montré plus haut sur l’exemple
d’architecture&nbsp;de microservices, où les liens
permettaient de facilement mettre en relation&nbsp;chacun des
services. La présence d’une section dédiée à la
gestion réseau justifie de revenir sur ce point particulier,
car c’est bien la couche réseau gérée
par Docker qui permet de mettre en œuvre les liens entre conteneurs.</p>
          <p class="defaut">Lorsqu’un lien est créé d’un
conteneur à un autre (notez que ce lien n’est pas bidirectionnel),
Docker récupère dynamiquement l’adresse IP du
premier dans son interface <span class="courier11">docker0</span>,
puis injecte le lien entre le nom fourni dans le lien - qui
sert d’alias - et l’adresse IP obtenue dans le fichier <span class="courier11">hosts</span> du second conteneur, démarré avec
l’option de liaison. On peut constater dans les commandes ci-dessous
la présence de l’entrée dans le fichier des alias
sur le second conteneur&nbsp;:</p>
          <pre class="programlisting"><code class="hljs cpp">jpg@Ubuntu1410:~$ docker run -d --name conteneur2 -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> nginx&nbsp;
<span class="hljs-number">677</span>da274ee579202eab5efb0dbd2d94034fa2a2c61d9e74ab7500ffbe43e40c5&nbsp;
&nbsp;
jpg@Ubuntu1410:~$ docker run --rm -it --link &nbsp;
conteneur2:serveurweb&nbsp;
ubuntu:trusty&nbsp;
root@<span class="hljs-number">6b</span>566fceb2ae:/<span class="hljs-meta"># cat /etc/hosts&nbsp;</span>
<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.11</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">6b</span>566fceb2ae&nbsp;
<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> &nbsp;localhost&nbsp;
::<span class="hljs-number">1</span> localhost ip6-localhost ip6-loopback&nbsp;
fe00::<span class="hljs-number">0</span> &nbsp; &nbsp;ip6-localnet&nbsp;
ff00::<span class="hljs-number">0</span> &nbsp; &nbsp;ip6-mcastprefix&nbsp;
ff02::<span class="hljs-number">1</span> &nbsp; &nbsp;ip6-allnodes&nbsp;
ff02::<span class="hljs-number">2</span> &nbsp; &nbsp;ip6-allrouters&nbsp;
<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.9</span> serveurweb <span class="hljs-number">677</span>da274ee57 conteneur2&nbsp;
root@<span class="hljs-number">6b</span>566fceb2ae:/<span class="hljs-meta"># exit&nbsp;</span>
<span class="hljs-built_in">exit</span></code></pre>
          <p class="defaut">L’alias <span class="courier11">serveurweb</span> a
bien été attaché à l’IP <span class="courier11">172.17.0.9</span>, qui était celle
prise par <span class="courier11">conteneur2</span>, lancé sur
l’image <span class="courier11">nginx</span>.</p>
          <p class="defaut">Nous avons surtout parlé de l’injection
dans les entrées d’alias pour réaliser le lien,
mais il est à noter que Docker tient compte des processus
qui ne peuvent pas utiliser la résolution de noms et fournit
des variables d’environnement remontant les mêmes informations&nbsp;:</p>
          <pre class="programlisting"><code class="hljs cs">jpg@Ubuntu1410:~$ docker run --rm -it --link &nbsp;
conteneur2:serveurweb ubuntu:trusty&nbsp;
root@<span class="hljs-number">1</span>aa38d9da502:/<span class="hljs-meta"># env&nbsp;</span>
SERVEURWEB_PORT_443_TCP=tcp:<span class="hljs-comment">//172.17.0.9:443&nbsp;</span>
HOSTNAME=<span class="hljs-number">1</span>aa38d9da502&nbsp;
TERM=xterm&nbsp;
SERVEURWEB_PORT_443_TCP_PORT=<span class="hljs-number">443</span>&nbsp;
SERVEURWEB_PORT_443_TCP_PROTO=tcp&nbsp;
SERVEURWEB_ENV_NGINX_VERSION=<span class="hljs-number">1.9</span><span class="hljs-number">.1</span><span class="hljs-number">-1</span>~jessie&nbsp;
&nbsp;
[<span class="hljs-meta">...</span>]&nbsp;
&nbsp;
SERVEURWEB_PORT_80_TCP=tcp:<span class="hljs-comment">//172.17.0.9:80&nbsp;</span>
SERVEURWEB_PORT_80_TCP_PROTO=tcp&nbsp;
SERVEURWEB_PORT_443_TCP_ADDR=<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.9</span>&nbsp;
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&nbsp;
&nbsp;
PWD=/&nbsp;
SERVEURWEB_PORT_80_TCP_ADDR=<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.9</span>&nbsp;
SHLVL=<span class="hljs-number">1</span>&nbsp;
HOME=/root&nbsp;
SERVEURWEB_PORT=tcp:<span class="hljs-comment">//172.17.0.9:80&nbsp;</span>
LESSOPEN=| /usr/bin/lesspipe %s&nbsp;
SERVEURWEB_NAME=/clever_darwin/serveurweb&nbsp;
LESSCLOSE=/usr/bin/lesspipe %s %s&nbsp;
SERVEURWEB_PORT_80_TCP_PORT=<span class="hljs-number">80</span>&nbsp;
_=/usr/bin/env</code></pre>
          <p class="defaut">Dans les processus logiciels, il est parfois
plus simple d’accéder à une variable d’environnement,
par exemple s’il ne s’agit que de lire une information sans réaliser
d’appel sur le service dans un premier temps. De manière
générale, les variables d’environnement sont le
moyen le plus universellement reconnu d’échanger de l’information
simple entre deux contextes.</p>
          <p class="defaut">La gestion des liens permet aux personnes
en charge de la conception des conteneurs de ne pas se soucier de
la façon dont ils seront déployés et
mis en relation les uns avec les autres. Dans ce sens, ce mécanisme
constitue un réel outil DevOps.</p>
        </div>
        <div class="sect3" id="refTitle5">
          <h3 class="title">e. Extension à l’état de santé des
conteneurs</h3>
          <p class="defaut"><var style="display:none"> HEALTHCHECK</var>Le mot-clé <span class="courier11">HEALTHCHECK</span> permet
de spécifier une commande à exécuter
pour valider l’état de santé d’un conteneur. Il
s’agit en général d’une commande très simple
qui va tester fonctionnellement le processus tournant dans le conteneur
et décider si la réponse&nbsp;montre que le
conteneur est non seulement lancé, mais qu’il réagit
correctement. Conformément aux conventions habituelles sur
les scripts, si la commande renvoie <span class="courier11">0</span>,
c’est que tout va bien, et si elle renvoie <span class="courier11">1</span>,
alors le processus est considéré comme en panne.
Des paramètres de nombre d’essais (<span class="courier11">--retries</span>)
avec intervalle entre chaque (<span class="courier11">--interval</span>)
et de délai maximum d’attente (<span class="courier11">--timeout</span>)
permettent toutefois de ne pas prendre une décision tranchée
dès le premier appel et d’attendre&nbsp;éventuellement
qu’un processus un peu long au démarrage se mette en route
sans remonter d’alerte prématurée. C’est d’ailleurs
principalement pour ce genre de choses que le mécanisme
est intéressant, comme nous allons le voir dans l’exemple
ci-dessous.</p>
          <p class="defaut">Une solution de test pourrait être
composée d’un serveur web (image <span class="courier11">nginx</span> par
exemple) et d’une base de données (image <span class="courier11">postgres</span>), le premier ayant une dépendance
sur la seconde. Dans le fichier <span class="courier11">docker-compose.yml</span> les assemblant,
il est possible de spécifier ceci grâce à la
grammaire suivante&nbsp;:</p>
          <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">version</span>: ’2<span class="hljs-selector-class">.1</span>’&nbsp;
<span class="hljs-selector-tag">services</span>:&nbsp;
&nbsp;&nbsp;<span class="hljs-selector-tag">web</span>:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">image</span><span class="hljs-selector-pseudo">:nginx</span><b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">depends_on</span>: <span class="hljs-selector-tag">db</span></b>&nbsp;
&nbsp;&nbsp;<span class="hljs-selector-tag">db</span>:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">image</span>: <span class="hljs-selector-tag">postgres</span></code></pre>
          <p class="defaut">Le problème de cette approche est
que, si le code contenu dans le serveur web (non montré ici)
fait une confiance aveugle au mécanisme de dépendance,
il peut planter car un appel à la base de données
va générer une erreur si celle-ci n’est pas prête.
Or, par défaut, le mécanisme de Docker Compose
associé à <span class="courier11">depends_on</span> ordonne
les lancements des conteneurs pour que les dépendances
soient exécutées dans l’ordre, mais ne fait que
valider que le processus logiciel a bien démarré pour
passer à celui qui en dépend. Et il se trouve
que de nombreux logiciels mettent un peu de temps à démarrer,
et le fait que le processus soit lancé ne signifie pas
qu’il est prêt à recevoir des requêtes
(ce comportement est celui de la plupart des moteurs de bases de
données). Idéalement, c’est le serveur web qui
devrait faire en sorte de réessayer l’appel à la
base de données à intervalles réguliers
(mais avec une limite) jusqu’à ce que tout soit prêt.
Il s’agit du seul moyen d’assurer que les services sont bien indépendants
et robustes. Toutefois, nous n’avons pas toujours la main sur le
code source et il peut être utile de mettre en place ce
comportement par le biais de Docker Compose, même s’il
s’agit d’un pis-aller.</p>
          <p class="defaut">C’est ce que propose la grammaire étendue
suivante&nbsp;:</p>
          <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">version</span>: ’2<span class="hljs-selector-class">.1</span>’&nbsp;
<span class="hljs-selector-tag">services</span>:&nbsp;
&nbsp;&nbsp;<span class="hljs-selector-tag">web</span>:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">image</span><span class="hljs-selector-pseudo">:nginx</span><b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">depends_on</span>:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">db</span>:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">condition</span>: <span class="hljs-selector-tag">service_healthy</span></b>&nbsp;
&nbsp;&nbsp;<span class="hljs-selector-tag">db</span>:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">image</span>: <span class="hljs-selector-tag">postgres</span><b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">heathcheck</span></b>:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag">test</span>: "<span class="hljs-selector-tag">pg_isready</span> <span class="hljs-selector-tag">-h</span> <span class="hljs-selector-tag">localhost</span> <span class="hljs-selector-tag">-p</span> 5432 <span class="hljs-selector-tag">-U</span> <span class="hljs-selector-tag">postgres</span>"</code></pre>
          <p class="defaut">Par défaut, le comportement est d’attendre <span class="courier11">service_starting</span>, mais le
fait de passer <span class="courier11">service_healthy</span> à l’attribut <span class="courier11">condition</span> va forcer la dépendance
du service <span class="courier11">web</span> au service <span class="courier11">db</span> à attendre pour lancer
le premier que le second soit non seulement démarré,
mais en plus en bonne santé (c’est-à-dire prêt à recevoir
et exécuter des ordres, pour la plupart des serveurs logiciels).</p>
          <p class="defaut">Bien évidemment, la façon
de détecter que l’application est prête à fonctionner varie
pour chaque logiciel et il faudra se référer à la
documentation pour trouver une façon de faire adaptée.
Pour donner un autre exemple que l’utilisation de <span class="courier11">pg_isready</span> ci-dessus, qui
est un utilitaire dédié pour les bases de données PostgreSQL,
voici une méthode adaptée à un moteur
d’indexation ElasticSearch&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript">&nbsp;&nbsp;elasticsearch:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;image: elasticsearch:<span class="hljs-number">1.7</span><span class="hljs-number">.6</span>-alpine&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;container_name: es&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ports:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span><b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;healthcheck:</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test: [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"nc"</span>, <span class="hljs-string">"-z"</span>, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"9200"</span>]&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval: <span class="hljs-number">3</span>s&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout: <span class="hljs-number">5</span>s&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retries: <span class="hljs-number">20</span></code></pre>
          <p class="defaut">Dans ce cas, c’est la commande <span class="courier11">nc</span> permettant de vérifier
la présence d’un port 9200 ouvert par ElasticSearch qui
permet de valider l’état prêt du serveur applicatif
d’indexation,&nbsp;avec des appels à intervalles réguliers.</p>
        </div>
        <div class="sect3" id="refTitle6">
          <h3 class="title">f. Approche complètement découplée</h3>
          <p class="defaut">Au risque de la lourdeur, l’auteur insiste
sur l’importance de ne pas se reposer, lorsque c’est possible, sur
le mécanisme montré ci-dessus. Le bon endroit
pour gérer la robustesse de connexion est dans le serveur
appelant (dans l’exemple ci-dessus, l’applicatif qui serait exposé par
Nginx) et non dans un processus externe comme Docker Compose. Il
en va de l’autonomie du service, essentielle pour assurer la robustesse
et la montée en charge. Ceci est particulièrement vrai
dans une architecture de microservices, se devant d’éviter
toute dépendance à un mécanisme externe
qui induit donc un couplage technologique potentiellement pénalisant
pour l’évolutivité comme pour la performance du système.</p>
          <p class="defaut">En dehors de toute considération
sur Docker, les différents composants dans une vraie architecture
de services doivent être parfaitement indépendants
les uns des autres. Or, le fait d’opérer une attente du
fonctionnement d’un service pour en démarrer un autre rétablit
un couplage, potentiellement dommageable à l’architecture
globale.</p>
          <p class="defaut">Une solution alternative, plus exigeante mais
permettant une isolation complète, est de faire en sorte
que le service possédant une dépendance fonctionnelle
envers un autre n’exprime pas cette dépendance au niveau
applicatif et gère l’absence de réaction logicielle
au niveau fonctionnel (l’abandon complet de l’attribut <span class="courier11">depends_on</span> est alors possible).
Les solutions sont nombreuses&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1">Utilisation de Retry
Policies pour recommencer l’émission de l’appel jusqu’à résolution
du problème, avec un délai entre chaque essai
et un nombre maximum d’essais (comme précisé,
ceci doit se faire dans le service concerné, avec une éventuelle
délégation à un composant interne au
processus, mais sans abandon de la responsabilité à destination
d’un autre à qui elle n’appartient pas du point de vue
fonctionnel).<var style="display:none"> Retry Policies</var></p>
              </li>
              <li class="liste1">
                <p class="liste1">Mise en place de queues de messages
de type MSMQ, RabbitMQ, etc. qui vont permettre un découplage
asynchrone et, en fonction des paramètres utilisés,
une robustesse&nbsp;supplémentaire par la persistance
disque et le mécanisme dit "Store &amp; Forward" (un message
ne peut être supprimé de la persistance du serveur émetteur
que lorsque son acquittement par le serveur récepteur prouve
qu’il a été persisté avec succès
sur ce dernier, rendant sa perte par une panne pendant le transport
impossible).&nbsp;<var style="display:none"> MSMQ</var><var style="display:none"> RabbitMQ</var></p>
              </li>
              <li class="liste1">
                <p class="liste1">Redirection vers un autre service
proposant une fonctionnalité moins sophistiquée
mais potentiellement suffisante dans un cas dégradé.
Un exemple est de fournir la dernière valeur connue d’un
cours de bourse en spécifiant la date et l’heure de valeur,&nbsp;en
remplacement d’une interrogation synchrone de ce cours. Une valeur
en provenance d’un cache est souvent plus utile qu’aucune réponse.
Dans certains cas de valeurs évoluant lentement (par exemple,
appartenance d’une commune à telle ou telle communauté de
communes), cette valeur "imparfaite" peut même avoir toutes
les chances d’être en fait la bonne.</p>
              </li>
              <li class="liste1">
                <p class="liste1">Mise en place d’une solution de
secours en interne par le service. Par exemple, si un service délègue
sa persistance à une base de données et que celle-ci
ne répond pas, il peut prendre comme décision
de persister l’information concernée sur un fichier dans
un volume et de repousser cette donnée vers la base de
données lors du prochain accès réussi.
Ainsi, la donnée est en sécurité, même
en cas de coupure d’électricité, et le service
est rendu à l’utilisateur, même si certaines fonctionnalités
seront temporairement indisponibles.</p>
              </li>
              <li class="liste1">
                <p class="liste1">etc.</p>
              </li>
            </ul>
          </div>
          <p class="defaut">Nous n’approfondissons pas plus ce sujet,
mais les lecteurs souhaitant mettre en place une architecture distribuée
auront ainsi quelques pistes pour creuser le sujet.</p>
        </div>
        <div class="sect3" id="refTitle7">
          <h3 class="title">g. Autres options</h3>
          <p class="defaut">Nous renvoyons à la documentation
de Docker pour la liste imposante des paramétrages réseau,
qui répond à quasiment tous les besoins, des plus
simples montrés ci-dessus aux plus sophistiqués
qui n’ont pas leur place dans un livre généraliste.</p>
          <p class="defaut">La page <a class="url" href="https://docs.docker.com/reference/run/" target="_blank">https://docs.docker.com/reference/run/</a> donne
tous les pointeurs sur les options&nbsp;réseau accessibles
au lancement d’un conteneur. Quant au paramétrage au niveau&nbsp;du
démon Docker, il est couvert par la page <a class="url" href="https://docs.docker.com/articles/networking/" target="_blank">https://docs.docker.com/articles/networking/</a></p>
          <p class="defaut">Ces deux liens vous montreront comme gérer
les DNS, modifier l’adresse MAC d’une interface réseau,
changer la passerelle, piloter les adresses IP des conteneurs, gérer
IPv6, etc.</p>
        </div>
        <div class="sect3" id="refTitle8">
          <h3 class="title">h. Limites de la couche réseau existante</h3>
          <p class="defaut">Malgré cette richesse d’options,
Docker souffre tout de même de limitations sur sa capacité&nbsp;réseau,
la plus importante d’entre elles étant que l’interface
réseau commune entre les conteneurs est liée à la
machine hôte. La conséquence la plus visible est
qu’il est impossible, en utilisant Docker seul, de réaliser
un lien entre deux conteneurs portés par deux démons
Docker fonctionnant sur deux machines séparées.</p>
          <p class="defaut">De nombreuses solutions ont été proposées
et développées sur les dernières années,
mais un premier niveau de réduction de l’offre
a déjà été opéré durant les
années 2016 et 2017, surtout depuis la version 1.12 de
Docker qui a industrialisé fortement l’approche&nbsp;intégrée
d’orchestrateur, dite mode Swarm. Sans être aussi
sophistiquée que DC/OS de Mesos ou Kubernetes
de Google, le mode Swarm de Docker est une approche efficace permettant
de relier en réseau des démons Docker de façon
qu’ils apparaissent comme un seul démon de forte
capacité, et avec en plus une gestion des réseaux
overlay et un DNS automatique qui rendent extrêmement simple
son exploitation conjointe avec les autres outils de l’écosystème
Docker.</p>
          <p class="defaut">Le fonctionnement de Swarm sera montré dans
le prochain chapitre, où l’application exemple
sera mise en place sur un cluster de trois machines. Nous n’entrerons
toutefois pas dans le détail de ce mode de fonctionnement,
car il est désormais acquis que Kubernetes est le choix
par défaut pour les orchestrateurs. Pour ce qui est de
la richesse&nbsp;de paramétrage réseau, ce
dernier va encore plus loin et nous aborderons rapidement&nbsp;sa
façon de gérer les expositions de conteneurs Docker,
sans toutefois approfondir&nbsp;autant que dans le livre sur Kubernetes
aux mêmes Éditions ENI.</p>
          <p class="defaut">En conclusion, les limitations de gestion
du réseau avec Docker sont désormais de l’histoire
ancienne et il existe des solutions pour à peu près
toutes les mises en œuvre imaginables.</p>
        </div>
      </div>
      <div class="sect2" id="refTitle9">
        <h2 class="title">2. Les volumes Docker<var style="display:none"> Volumes</var></h2>
        <div class="sect3" id="refTitle10">
          <h3 class="title">a. Le problème de la persistance<var style="display:none"> Persistance</var></h3>
          <p class="defaut">La gestion des couches de Docker fait que
les images servant de base au démarrage d’une instance
de conteneur ne sont jamais modifiées. Elles sont en lecture
seule, et toutes les modifications sur le conteneur sont réalisées
dans une couche supplémentaire, qui stocke les modifications.
Il est ensuite possible d’utiliser l’opération <span class="courier11">commit</span> pour stocker ces modifications
de manière définitive dans une autre image.</p>
          <p class="defaut">Cette méthode est adaptée
lorsque l’utilisateur est en phase de construction d’une image,
mais pas du tout pour l’exploitation d’une image existante.</p>
          <p class="defaut">Imaginons par exemple le cas d’un conteneur
exposant un service de base de données. Par défaut,
toutes les modifications réalisées dans la base
de données vont donc se retrouver&nbsp;dans cette couche
temporaire en lecture/écriture, et que se passera-t-il
si personne ne pense à utiliser l’option <span class="courier11">commit</span> lors de l’arrêt du
conteneur&nbsp;? Les données patiemment récoltées
auprès des utilisateurs, qu’il s’agisse de commandes, de
demandes&nbsp;de dossiers en ligne, etc., seront purement et
simplement perdues.</p>
          <p class="defaut">Ce mode de fonctionnement est bien évidemment
inacceptable et c’est pour cela que Docker a prévu une
gestion des volumes pour la persistance des données.</p>
        </div>
        <div class="sect3" id="refTitle11">
          <h3 class="title">b. Les volumes comme solution simple</h3>
          <p class="defaut">Pour expliquer le principe de fonctionnement
des volumes, nous allons nous servir de l’image officielle de MongoDB.
Voici un extrait du <span class="courier11">Dockerfile</span> pour
l’image en version 3.0&nbsp;:</p>
          <pre class="programlisting"><code class="hljs vbnet"><span class="hljs-keyword">FROM</span> debian:wheezy&nbsp;
&nbsp;
[...]&nbsp;
&nbsp;
RUN <span class="hljs-keyword">set</span> -x \&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; apt-<span class="hljs-keyword">get</span> update \&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; apt-<span class="hljs-keyword">get</span> install -y mongodb-org=$MONGO_VERSION \&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; rm -rf /var/<span class="hljs-keyword">lib</span>/apt/lists/* \&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; rm -rf /var/<span class="hljs-keyword">lib</span>/mongodb \&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; mv /etc/mongod.conf /etc/mongod.conf.orig&nbsp;
&nbsp;&nbsp;&nbsp;
RUN mkdir -p /data/db &amp;&amp; chown -R mongodb:mongodb /data/db&nbsp;
VOLUME /data/db&nbsp;
&nbsp;
COPY docker-entrypoint.sh /entrypoint.sh&nbsp;
ENTRYPOINT [<span class="hljs-string">"/entrypoint.sh"</span>]&nbsp;
&nbsp;
EXPOSE <span class="hljs-number">27017</span>&nbsp;
CMD [<span class="hljs-string">"mongod"</span>]</code></pre>
          <p class="defaut">Le mot-clé <span class="courier11">VOLUME</span> a
pour effet que les conteneurs instanciés sur cette image ne
pousseront pas les modifications réalisées localement
dans <span class="courier11">/data/db</span> (comportement
standard de MongoDB) sur la couche en écriture, mais sur
un répertoire géré par Docker&nbsp;et
directement associé au disque dur de la machine hôte.</p>
          <p class="defaut">Nous allons montrer ceci par une courte manipulation&nbsp;:</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Lancez un conteneur basé sur l’image <span class="courier11">mongo</span>, en utilisant la ligne de commande
qui suit&nbsp;:</p>
          </div>
          <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">docker</span> <span class="hljs-selector-tag">run</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-tag">--name</span> <span class="hljs-selector-tag">db</span> <span class="hljs-selector-tag">-p</span> 27017<span class="hljs-selector-pseudo">:27017</span> <span class="hljs-selector-tag">mongo</span><span class="hljs-selector-pseudo">:3.0.3</span></code></pre>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Connectez-vous ensuite à la base de
données MongoDB (le port 27017 est celui utilisé par
défaut)&nbsp;:</p>
          </div>
          <pre class="programlisting"><code class="hljs">mongo</code></pre>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Si vous ne disposez pas du client <span class="courier11">mongo</span> pour accéder à la
base MongoDB, vous pouvez l’installer par la commande <span class="courier11">apt-get install mongodb-clients</span> sur
Ubuntu, ou l’équivalent dans votre distribution.</p>
            </div>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Positionnez-vous sur la base <span class="courier11">mydb</span> avec la commande <span class="courier11">use mydb</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Effectuez une modification dans cette base,
par exemple un ajout d’une entrée dans une collection <span class="courier11">Personnes</span>, comme ceci&nbsp;:</p>
          </div>
          <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.Personnes</span><span class="hljs-selector-class">.insert</span>({ <span class="hljs-attribute">nom&nbsp;</span>: <span class="hljs-string">"Lagaffe"</span>, prenom&nbsp;: <span class="hljs-string">"Gaston"</span>})</code></pre>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Sortez de la base de données par la
commande <span class="courier11">exit</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Lancez une commande <span class="courier11">docker
inspect db</span> pour voir les paramètres du conteneur <span class="courier11">db</span>, et cherchez une information contenant
le nom <span class="courier11">volume</span>, comme suit&nbsp;:</p>
          </div>
          <pre class="programlisting"><code class="hljs php">&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"Volumes"</span>: {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"/data/db"</span>:&nbsp;
<span class="hljs-string">"/var/lib/docker/vfs/dir/1e3960af56b96bda0d3e808d6321cee6a712bbf1&nbsp;
&nbsp;
7b0f9d84e664dd8da9401b5c"</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"VolumesRW"</span>: {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"/data/db"</span>: <span class="hljs-keyword">true</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre>
          <p class="p100"> </p>
          <pre class="literallayoutBis"><code class="hljs javascript">/<span class="hljs-keyword">var</span>/lib/docker/vfs/dir/<span class="hljs-number">1e3960</span>af56b96bda0d3e808d6321cee6a712bbf17b0f9d8</code></pre>
          <p class="defaut"><span class="courier11">4e664dd8da9401b5c</span> est
le répertoire dans lequel Docker a redirigé le
contenu écrit par le serveur MongoDB dans <span class="courier11">/data/db</span> lors de
l’exécution du conteneur <span class="courier11">db</span>.
Nous allons lancer un second conteneur pointant sur ce volume pour montrer
que c’est bien ce contenu sur le disque dur qui héberge
les données de la base de données&nbsp;:</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Démarrez un conteneur qui lie explicitement
ce volume avec <span class="courier11">/data/db</span>,
en utilisant un autre port pour ne pas avoir de conflit avec 27017,
mais aussi un autre nom, vu que <span class="courier11">db</span> est
pour l’instant toujours utilisé&nbsp;:</p>
          </div>
          <pre class="programlisting"><code class="hljs powershell">docker run -d --name dbalt -p <span class="hljs-number">27018</span>:<span class="hljs-number">27017</span> -v&nbsp;
<span class="hljs-string">"/var/lib/docker/vfs/dir/1e3960af56b96bda0d3e808d6321cee6a712bbf1&nbsp;
&nbsp;
7b0f9d84e664dd8da9401b5c"</span>:/<span class="hljs-keyword">data</span>/db mongo:<span class="hljs-number">3.0</span>.<span class="hljs-number">3</span></code></pre>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Connectez-vous à la base MongoDB exposée
par ce nouveau conteneur&nbsp;:<var style="display:none"> MongoDB</var></p>
          </div>
          <pre class="programlisting"><code class="hljs">mongo -p 27018</code></pre>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Positionnez-vous sur la base <span class="courier11">mydb</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Cherchez les données avec la commande <span class="courier11">db.Personnes.find()</span>.</p>
          </div>
          <p class="defaut">Vous devriez obtenir un affichage comme suit,
prouvant que nous avons récupéré ces
données depuis le volume&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript">&gt; db.Personnes.find()&nbsp;
{ <span class="hljs-string">"_id"</span>&nbsp;: ObjectId(<span class="hljs-string">"559001f2fff688b1a73b7075"</span>), <span class="hljs-string">"nom"</span>&nbsp;:&nbsp;
<span class="hljs-string">"Lagaffe"</span>, <span class="hljs-string">"prenom"</span>&nbsp;: <span class="hljs-string">"Gaston"</span> }</code></pre>
          <p class="defaut">Cet exemple montre que le simple positionnement
du mot-clé <span class="courier11">VOLUME</span> dans le
fichier <span class="courier11">Dockerfile</span> avec le nom du
répertoire à garder permet d’outrepasser le problème énoncé au
début de cette section. Nous allons maintenant explorer
quelques usages plus précis des volumes.</p>
        </div>
        <div class="sect3" id="refTitle12">
          <h3 class="title">c. Lien direct sur un répertoire local</h3>
          <p class="defaut">Le premier usage non basique des volumes consiste à ne
pas laisser Docker choisir un répertoire, mais à lui
en passer un en paramètre sur lequel nous pourrons facilement
faire pointer les données associées au volume.
Par exemple, nous pouvons lancer un autre conteneur utilisant l’image
mongo sur lequel nous préciserions que le volume associé&nbsp;à <span class="courier11">/data/db</span> doit pointer
sur le répertoire <span class="courier11">persistance</span> spécialement
créé à cet effet sur la machine hôte.</p>
          <p class="defaut">En explorant ce répertoire, nous
verrons alors l’arborescence typique créée par le
serveur MongoDB pour le stockage des données qui lui sont
confiées&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/05EP42.png" title="images/05EP42.png" src="IMAGES/05EP42.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmN7MPSmy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Cette approche est bien sûr un peu
plus complexe à initialiser (une option de plus dans la
commande <span class="courier11">docker run</span>), mais elle
est bien plus facile à exploiter (les données
sont là où nous l’avons demandé, et non
dans un répertoire enfoui dans les entrailles de Docker
et qu’il nous faut retrouver par une inspection du conteneur concerné).</p>
          <p class="defaut">L’affectation automatique de volume par Docker
a par contre l’avantage qu’il n’est pas nécessaire pour
l’exploitant d’anticiper la façon dont le stockage sera généré.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Comme pour les volumes affectés
automatiquement, il est bien sûr possible de passer plusieurs
paramètres de définition de volumes.</p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle13">
          <h3 class="title">d. Partage de volumes</h3>
          <p class="defaut">De la même façon que les
liens entre conteneurs, exposés plus haut, permettent de
brancher un alias d’un conteneur sur l’IP d’un autre par une simple option,
il est possible de partager des volumes entre deux conteneurs sans avoir à retrouver
l’identifiant du volume par un <span class="courier11">docker inspect</span>.</p>
          <p class="defaut">L’option à utiliser est <span class="courier11">--volumes-from</span> suivie du nom du conteneur
cible. En repartant de l’exemple ci-dessus, par exemple, il est
possible de connecter un second conteneur sur le volume exposé par
le premier, ce qui permettra un accès identique au contenu
de <span class="courier11">/data/db</span>.</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/05EP43.png" title="images/05EP43.png" src="IMAGES/05EP43.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmN7MPSmy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Il faut, dans ces cas de partage de répertoire,
veiller à ce que les deux conteneurs gèrent correctement
les droits de précédence sur l’écriture
des fichiers. Dans l’exemple ci-dessus, il est fortement recommandé que
le second conteneur ne touche pas au contenu du répertoire
MongoDB, sous peine de corruption de données. Afin de sécuriser
ceci, il peut être utile de recourir à l’option&nbsp;:<span class="courier11">ro</span>, qui permet de créer un
volume en lecture seule et qui fonctionne également avec <span class="courier11">--volumes-from</span>, comme le montre la
poursuite de notre exemple ci-dessous&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/05EP44.png" title="images/05EP44.png" src="IMAGES/05EP44.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmN7MPSmy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Cette fonctionnalité est souvent
utilisée dans le cadre d’infrastructures Docker pour permettre
une sauvegarde simple des contenus de volume&nbsp;: à intervalles
réguliers, un conteneur est lancé avec un lien
en lecture seule sur les volumes des conteneurs à sauvegarder,
une archive est générée à partir
de ce contenu (à l’aide de l’outil <span class="courier11">tar</span>,
par exemple) et envoyée sur un NAS (<span class="italic">Network Attached Storage</span>),
lui-même accédé par un autre lien de
volume. Le conteneur est alors arrêté et purgé,
et la prochaine opération de sauvegarde en utilisera un
nouveau, ce qui permet de limiter les effets de bord.</p>
          <p class="defaut">Dans le cas où un serveur applicatif
bloque la lecture des fichiers, il faut procéder autrement&nbsp;et
utiliser la fonction dédiée du serveur pour l’export
d’une archive. La pratique standard est alors de lancer la commande
sur le conteneur par une commande <span class="courier11">docker
exec</span>.</p>
        </div>
        <div class="sect3" id="refTitle14">
          <h3 class="title">e. Gestion des volumes orphelins<var style="display:none"> Volumes:orphelins</var></h3>
          <p class="defaut">La sécurisation des données
assurée par Docker grâce aux volumes a bien sûr un
prix, en l’occurrence la possibilité de générer
des volumes orphelins si les conteneurs ne sont pas arrêtés
de manière propre. Si Docker trouve la commande <span class="courier11">VOLUME</span> dans le <span class="courier11">Dockerfile</span>,&nbsp;le
répertoire correspondant sera stocké sur le disque
dur, même si la personne lançant le conteneur
n’a pas explicitement émis d’option en ce sens
et peut donc ne pas en avoir conscience.</p>
          <p class="defaut">Tant que les bonnes pratiques sont respectées
et que les conteneurs sont supprimés avec l’option <span class="courier11">-v</span>, pas de problème&nbsp;:
Docker comptera le nombre de conteneurs accédant au volume,
en l’incrémentant à chaque liaison par un conteneur
et en le décrémentant à chaque conteneur
proprement supprimé. Enfin, lorsque le nombre de conteneurs
associés au volume sera retombé à zéro,
le volume sera purgé.</p>
          <p class="defaut">Par contre, si ne serait-ce qu’un seul volume
est arrêté par la simple commande <span class="courier11">docker&nbsp;rm</span> sans l’option de
gestion du volume, le compteur ne descendra jamais à zéro.
Il ne sera donc pas supprimé, mais aucun conteneur n’utilisera plus
son contenu. Le volume est alors dit orphelin.</p>
          <p class="defaut">Le problème associé aux
volumes orphelins est qu’ils utilisent de l’espace disque pour rien.
Heureusement, des scripts existent pour les supprimer, par exemple
celui disponible sur la page <a class="url" href="https://gist.github.com/eliasp/7720943" target="_blank">https://gist.github.com/eliasp/7720943</a>. Attention
toutefois à ne pas utiliser ce script à tort et à travers.
En particulier, il ne devrait normalement jamais avoir à être
mis en œuvre sur une plateforme de production.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Attention, les risques de perte de
données consécutive à une utilisation
incorrecte sont réels. Ce n’est pas pour rien que la commande <span class="courier11">docker system prune</span> ne supprime pas
ces volumes orphelins, contrairement par exemple à des
réseaux sur lesquels plus aucun&nbsp;conteneur ne s’appuie.
Il faut utiliser la commande dédiée <span class="courier11">docker volume prune</span>, et bien sûr
confirmer les effacements, pour arriver à un tel effet.</p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle15">
          <h3 class="title">f. Sophistication de l’approche</h3>
          <p class="defaut">Toute l’approche autour des volumes doit être
adaptée à l’environnement. Les exemples ci-dessus
sont simples à dessein, car il s’agit de démontrer
la fonctionnalité plutôt que de perdre le lecteur
dans des gestions de droits, des partages de répertoires,
etc. Il n’empêche que&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1">une utilisation plus
réaliste pour la sauvegarde pointerait sur un NAS ou une
baie SAN (<span class="italic">Storage Area Network</span>)&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">la sauvegarde serait associée à une
tâche planifiée supervisée et testée
par un mécanisme indépendant&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">la persistance serait potentiellement
gérée par un cluster dédié,
avec une approche comme CouchDB ou MongoDB en version cluster&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">un système de droits devrait être
mis en place pour ne pas que n’importe quel conteneur accède
aux données d’un autre&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">etc.</p>
              </li>
            </ul>
          </div>
        </div>
        <div class="sect3" id="refTitle16">
          <h3 class="title">g. Application à la gestion des logs</h3>
          <p class="defaut">L’approche "standard" de la gestion des logs
dans Docker consiste à faire verser toutes les traces par
les conteneurs dans la sortie standard de la console, de façon à pouvoir
les exploiter par la commande <span class="courier11">docker logs</span>.
Cette approche a l’avantage d’une grande simplicité.</p>
          <p class="defaut">Toutefois, si des processus applicatifs utilisent
un répertoire pour stocker les logs, la gestion par un
volume permettra de centraliser ceux-ci sur un répertoire
de la machine hôte, tout en donnant au conteneur l’illusion
d’un répertoire fixe. Ainsi, la commande ci-dessous a l’avantage
que le code de l’application associée pourra simplement écrire
ses fichiers dans <span class="courier11">/log</span>,
sans se soucier de changer de répertoire un jour&nbsp;:</p>
          <pre class="programlisting"><code class="hljs cpp">docker run -v /tmp/traces:/<span class="hljs-built_in">log</span> appliserveur</code></pre>
          <p class="defaut">Du point de vue du code de génération
des traces, le travail est simplifié&nbsp;: il suffit
d’écrire le fichier dans <span class="courier11">/log</span>,
et ce répertoire peut tout à fait être écrit
en dur dans le code, car le mécanisme de conteneurs permettra
si nécessaire de l’aiguiller autre part. Cela simplifie
fortement la gestion des logs dans le code d’un serveur logiciel.</p>
          <p class="defaut">Un autre serveur pourrait avoir son code qui
envoie par défaut les logs dans <span class="courier11">/tmp</span>,
cela ne poserait pas de problème pour centraliser dans <span class="courier11">/tmp/traces</span>&nbsp;:</p>
          <pre class="programlisting"><code class="hljs">docker run -v /tmp/traces:/tmp secondeappli</code></pre>
          <p class="defaut">Au final, tous les logs seront accessibles
sur un répertoire central de la machine hôte (qui
peut pointer sur un partage externe, par ailleurs), ce qui facilitera l’analyse
de l’architecture&nbsp;microservices. Il faut juste observer
une convention sur le nommage des fichiers de façon que
les services ne génèrent pas des fichiers de même
nom. En général, ceci ne pose pas de problème,
les fichiers de logs roulants utilisant des noms basés
sur l’heure précise de démarrage ou un autre discriminant
fort. Un avantage de cette centralisation est que l’archivage et
la purge des logs sont centralisés, ce qui rend beaucoup
plus simple la mise en place d’une politique partagée pour
leur gestion.</p>
          <p class="defaut">Enfin, dans les cas plus industriels avec
de nombreux services, il faudra passer encore un cran au-dessus
et envisager l’utilisation d’un syslog pour collecter les logs,
voire passer sur une pile ELK (<span class="italic">ElasticSearch</span>, <span class="italic">LogStash</span>, <span class="italic">Kibana</span>)
pour leur exploitation. Lors de la mise en place des orchestrateurs,
ce mode de fonctionnement sera expliqué plus en détail.</p>
        </div>
        <div class="sect3" id="refTitle17">
          <h3 class="title">h. L’état de l’art</h3>
          <p class="defaut">La présente section sur les volumes
a été gardée depuis l’édition
précédente car elle permet de bien comprendre
le fonctionnement de Docker en lien avec les données persistantes
dans des fichiers, mais il convient de souligner que la façon
de faire recommandée est désormais de laisser
les orchestrateurs gérer cette couche de volume. Kubernetes,
par exemple, permet de sophistiquer fortement l’approche en séparant
les concepts de <span class="courier11">PersistentVolume</span> et <span class="courier11">PersistentVolumeClaim</span>, donnant ainsi
une grande souplesse à la gestion des volumes par la séparation
des ressources nécessaires au stockage des affectations
de portions de ces ressources, sous le contrôle de l’orchestrateur, à tel
ou tel service.</p>
          <p class="defaut">Dans l’exemple plus haut de déploiement
avec Docker Compose, nous avions créé un volume
extrêmement simple, avec tous les attributs par défaut
et qui se trouvait implémenté sous la forme d’un
fichier local, mais un coup d’œil à la commande <span class="courier11">docker volume</span> et en particulier aux
options de <span class="courier11">docker volume create</span> permet
de découvrir&nbsp;la possibilité d’adosser
la persistance des données à un bucket Amazon
S3, un storage Azure et d’autres systèmes de stockage extrêmement
variés.</p>
        </div>
      </div>
    </div></div></div></div></app-page-content><!----><!----><!----></div></kendo-pdf-export>