<kendo-pdf-export _ngcontent-uvf-c168="" papersize="A4" margin="2cm" id="div-book-content" class="col-12 col-sm-10 offset-0 div-book-content" uipath_custom_id="10"><div><app-page-content _ngcontent-uvf-c168="" _nghost-uvf-c166="" class="font-size-14 font-size-sm-20"><div _ngcontent-uvf-c166="" class="mainContent mt-4"><div _ngcontent-uvf-c166="" id="bookContent" class="bookContent"><div _ngcontent-uvf-c166="" id="content"><div class="sect1" style="abcpdf-tag-visible: true" id="AU_c76ed440-e4ba-452e-bc43-bf3bd22c5781" uri="ImagesUri_../download/5c180f28-f752-47db-98e8-8656c84b148d/images/">
      <h1 class="title">Bonnes pratiques</h1>
      <div class="sect2" id="refTitle0">
        <h2 class="title">1. Principe du cache local d’images<var style="display:none"> Cache</var></h2>
        <p class="defaut">Un utilisateur attentif aura certainement
noté la différence de temps entre la première
exécution d’un conteneur et les suivantes. La différence
est particulièrement notable lorsqu’un conteneur est basé sur
une image "lourde" comme <span class="courier11">ubuntu</span>,
et un peu moins sur les images de type "slim" ou <span class="courier11">alpine</span>. Lors de la première
exécution, Docker télécharge alors presque
une centaine de mégaoctets. À la seconde exécution
ainsi qu’aux suivantes, ce téléchargement n’a
plus lieu d’être, et le démarrage du conteneur
est rendu beaucoup plus rapide.</p>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">Nous parlons de démarrage
du conteneur, mais il peut aussi bien s’agir de la seule commande <span class="courier11">pull</span> de récupération
de l’image depuis le registre. Il se trouve que la commande <span class="courier11">run</span> est plus souvent utilisée,
et qu’elle lance de toute façon une commande <span class="courier11">pull</span> si l’image n’est pas disponible
localement.</p>
          </div>
        </div>
        <p class="defaut">Docker gère donc un cache pour les
images. Ce cache est local, et il se trouve que nous avons déjà plusieurs
fois observé son contenu par la commande <span class="courier11">docker images</span>. Le cache est tout simplement
ce que nous avions appelé jusqu’ici la liste des images
locales.&nbsp;Une commande <span class="courier11">docker pull</span> ne
fait que rapatrier en local (donc mettre en cache) une image qui
a une existence préalable sur le registre distant.</p>
        <p class="defaut">Comme nous l’avions vu dans le chapitre sur
les principes de Docker, instancier un conteneur revient, du point
de vue du contenu, à créer une nouvelle couche
en écriture sur une pile de couches existantes qui sont
accédées uniquement en lecture. En pratique, ces
couches sont systématiquement présentes lors du
lancement, mais pour des raisons différentes en fonction
du contexte&nbsp;:</p>
        <div class="divliste1">
          <ul class="liste1">
            <li class="liste1">
              <p class="liste1">Si l’image a été construite
localement, la commande de compilation <span class="courier11">docker
build</span> a automatiquement récupéré tout
l’empilement d’images sur lequel se basait le <span class="courier11">Dockerfile</span> au
moyen du mot-clé <span class="courier11">FROM</span>.</p>
            </li>
            <li class="liste1">
              <p class="liste1">Si l’image a été récupérée
depuis un registre, la commande <span class="courier11">pull</span> ou <span class="courier11">run</span> a ramené, là aussi,
toutes les couches nécessaires et pas seulement la plus haute
correspondant au tag fourni. Bien entendu, le mécanisme
de cache s’applique à tous les niveaux, et si une image
se base sur une autre qui elle-même se base sur une image
déjà présente, seules les deux premières
seront rapatriées.</p>
            </li>
            <li class="liste1">
              <p class="liste1">Si l’image a été chargée
depuis un fichier d’archive par la méthode <span class="courier11">load</span>, les images dont elle dépend
seront également déposées localement
si elle ne préexiste pas, car le fichier d’archive contient
tout.</p>
            </li>
          </ul>
        </div>
        <p class="defaut">La question de l’écrasement d’une
image par une autre qui aurait à un moment donné le
même tag ne se pose pas, car seul l’identifiant hexadécimal
d’une image fait foi. Imaginons par exemple qu’une archive ait été créée
pour une image qui se basait sur <span class="courier11">ubuntu:latest</span>,
mais il y a de cela plusieurs mois. Que se passe-t-il si nous chargeons
l’archive sur le cache local et que la version <span class="courier11">ubuntu:latest</span> a
changé depuis&nbsp;? En fait, rien de spécial,
car l’image chargée dépend d’une image Ubuntu
avec un identifiant et les autres images locales peuvent tout à fait
dépendre d’une autre image Ubuntu. Les identifiants ne
sont pas les mêmes, et l’image chargée sait qu’elle
doit toujours se baser sur l’image à partir de laquelle
elle a été compilée (et qui était
la plus à jour à l’époque). Le tag <span class="courier11">latest</span> est appliqué à une
autre image, avec un identifiant différent, mais cela ne
change rien pour l’image chargée. Toutefois, si on compile à nouveau
l’image à partir de son <span class="courier11">Dockerfile</span>,
elle sera mise à jour pour pointer sur la nouvelle image,
puisque le tag <span class="courier11">latest</span> utilisé dans
le <span class="courier11">Dockerfile</span> pointe sur celle-ci.<var style="display:none"> latest</var></p>
        <p class="defaut">Le plus simple est de montrer cette évolution
par quelques schémas, en commençant par décrire
les images dans le cache local autour de mi-mars 2015, c’est-à-dire
le moment où l’image qui nous servira d’exemple a été créée
pour la première fois, à l’occasion de
la première édition du présent ouvrage.
Elle était alors basée sur ce qui était à l’époque
la version Long Term Support la plus récente (<span class="courier11">latest</span>, en anglais) de l’image <span class="courier11">ubuntu</span>, à savoir la version 14.04&nbsp;:</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP52.png" title="images/04EP52.png" src="IMAGES/04EP52.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
        </div>
        <p class="defaut">La commande <span class="courier11">docker
save</span> a été utilisée pour créer
une archive correspondant à l’image étiquetée <span class="courier11">imagetest</span>. La commande incluant toute
la pile des images dépendantes, l’archive regroupe les
images d’identifiants <span class="courier11">e5afb9797f1a</span> et <span class="courier11">d0955f21bf24</span> (ainsi que toutes les
images composant <span class="courier11">ubuntu</span>, mais nous
ne montrons pas les images intermédiaires, pour simplifier).</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP53.png" title="images/04EP53.png" src="IMAGES/04EP53.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
        </div>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">Quitte à anticiper un peu
sur la section suivante, il peut être intéressant
pour la compréhension de la dernière phrase d’expliquer
la notion d’image intermédiaire. Les images affichées
par la commande <span class="courier11">docker images</span> sans
option sont les images qui résultent d’une compilation
d’un <span class="courier11">Dockerfile</span>, mais chaque ligne
du fichier génère en fait une&nbsp;image,
désignée comme intermédiaire. La commande
avec option <span class="courier11">docker images -a</span> permet
de visualiser toutes les images, y compris les intermédiaires.
Nous reviendrons&nbsp;juste après plus en détail
sur ces images.</p>
          </div>
        </div>
        <p class="defaut">Deux ans plus tard, lors de l’écriture
de la seconde édition de ce même ouvrage (version
que vous lisez actuellement), la version LTS la plus à jour
de l’image <span class="courier11">ubuntu</span> n’est plus la
même&nbsp;: il s’agit désormais de
la 16.04, dite Xenial Xerus.</p>
        <p class="defaut">La commande ci-dessous permet de retrouver
son identifiant, qui est la seule information stable. Comme nous
venons de le montrer, les étiquettes sont de leur côté,
libres de se déplacer d’une version d’image à une
autre, et seule l’attention de l’éditeur
garantit&nbsp;que ce mouvement fait sens&nbsp;:</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP54.png" title="images/04EP54.png" src="IMAGES/04EP54.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
        </div>
        <p class="defaut">Une autre machine qui serait censée
recevoir l’archive générée précédemment pourrait
alors présenter la structure ci-dessous&nbsp;:</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP55.png" title="images/04EP55.png" src="IMAGES/04EP55.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
        </div>
        <p class="defaut">On voit clairement que l’identifiant de l’image
n’est plus le même&nbsp;: il y a une nouvelle image
qui est apparue, et l’étiquette (tag, en langage Docker) <span class="courier11">ubuntu:latest</span> pointe désormais
sur cette nouvelle image.</p>
        <p class="defaut">Si une commande <span class="courier11">docker
load</span> est mise en œuvre pour restaurer l’image archivée
sur cette machine cible, nous obtiendrons le contenu suivant du
cache local des images&nbsp;:</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP56.png" title="images/04EP56.png" src="IMAGES/04EP56.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
        </div>
        <p class="defaut">L’image correspondant à l’ancienne
version d’Ubuntu (celle qui était étiquetée <span class="courier11">latest</span> au moment de la compilation
d’<span class="courier11">imagetest</span>) a été restaurée,
mais sans son étiquette. Cela montre la différence
claire qu’il y a entre ce qu’on appelle communément le
"nom" d’une image et son identifiant.</p>
        <p class="defaut">Le "nom" est en fait la composition textuelle
entre le dépôt (<span class="courier11">ubuntu</span>)
et le tag (<span class="courier11">latest</span>, par exemple),
et il ne s’agit pas réellement d’un libellé donné à une entité,
mais d’une description qui peut être multiple.</p>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">Pour être tout à fait
complet, le nom d’une telle image est même <span class="courier11">docker.io/library/ubuntu:latest</span>,
pour faire référence au fait que l’image est portée par
le registre Docker&nbsp;Hub et qu’elle fait partie des dépôts
officiels.</p>
          </div>
        </div>
        <p class="defaut">Par exemple, au moment de l’écriture
de ce chapitre, à la même image du dépôt <span class="courier11">ubuntu</span> étaient attachées
toutes les étiquettes suivantes&nbsp;:</p>
        <div class="divliste1">
          <ul class="liste1">
            <li class="liste1">
              <p class="liste1"><span class="courier11">20.04</span>&nbsp;:
la version selon son expression courte.</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">focal-20200729</span>&nbsp;:
la version avec la date de construction (29 juillet 2020) et la
série (Focal Fossa est le nom de code de la version 20.04).</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">focal</span>&nbsp;:
le nom de code seul, ce qui permet de pointer sur la dernière
version connue de la Focal Fossa, soit une 20.04 la plus à jour
possible.</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">latest</span>&nbsp;:
l’étiquette <span class="courier11">latest</span> est
encore à ce jour affectée à cette version 20.04,
car il s’agit d’une version Long Term Support. Il existe une version plus
récente d’Ubuntu, à savoir la 20.10, mais Ubuntu
sort régulièrement une version avec un support à long
terme et a décidé d’affecter le tag <span class="courier11">latest</span> à celle-ci, ce qui
obéit à une logique de stabilité.</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">rolling</span>&nbsp;:
l’étiquette <span class="courier11">rolling</span> correspond à la
dernière version largement utilisable, qu’elle soit LTS
ou pas. Il se trouve qu’au moment de l’écriture de cette
section, elle pointe également sur la 20.04 car la 20.10
est toujours en cours de développement.</p>
            </li>
          </ul>
        </div>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">La version en cours de développement
d’Ubuntu bénéficie elle aussi d’une image Docker,&nbsp;même
si elle ne s’adresse bien sûr qu’aux testeurs. Elle peut être appelée
en utilisant&nbsp;l’étiquette <span class="courier11">devel</span>.</p>
          </div>
        </div>
        <p class="defaut">L’identifiant d’une image, quant à lui,
peut être vu comme une empreinte d’une image&nbsp;:
dès que le contenu change, l’identifiant doit changer.
D’où sa représentation sous la forme d’un condensat
(hash en anglais), pour le lecteur ayant des notions de cryptographie.</p>
        <p class="defaut">Nous parlions au-dessus de stabilité,
et c’est bien cette qualité primordiale des approches&nbsp;par
conteneurs qui est à l’œuvre derrière
le fonctionnement expliqué un peu plus haut. Lorsque l’image
archivée est restaurée, il est fondamental que
toute la pile d’images sur laquelle elle se base soit absolument
identique à celle d’origine. Une des promesses des approches
par conteneurs est de garantir qu’une image fonctionnera toujours
de la même manière, d’une machine à l’autre,
d’un contexte d’utilisation à l’autre et d’un lancement à l’autre. Il
est donc crucial qu’aucun changement ne puisse intervenir qui viendrait troubler
cette stabilité. C’est d’ailleurs pour cette raison qu’une
archive d’image réalisée par <span class="courier11">docker
save</span> embarque tout. Lors de la restauration, si une image
existe déjà avec exactement le même identifiant,
tant mieux. Mais si ne serait-ce qu’un octet a changé,
c’est l’image d’origine qui sera restaurée et servira.</p>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">La compréhension de la différence
entre un tag et un identifiant d’image est absolument fondamentale
pour la bonne mise en œuvre de Docker.</p>
          </div>
        </div>
      </div>
      <div class="sect2" id="refTitle1">
        <h2 class="title">2. Principe du cache à la compilation<var style="display:none"> Cache</var></h2>
        <div class="sect3" id="refTitle2">
          <h3 class="title">a. Retour sur les images intermédiaires</h3>
          <p class="defaut">Nous avons brièvement évoqué un
peu plus haut la notion d’image intermédiaire. Il convient à présent
d’expliquer plus en détail à quoi celle-ci correspond.
Prenons par exemple l’image <span class="courier11">repeater</span> qui
nous a déjà servi et dont nous redéfinissons
le <span class="courier11">Dockerfile</span>&nbsp;comme suit&nbsp;:</p>
          <pre class="programlisting"><code class="hljs perl">FROM ubuntu:latest&nbsp;
LABEL maintainer=<span class="hljs-string">"jp.gouigoux@free.fr"</span>&nbsp;
LABEL version=<span class="hljs-string">"1.0"</span>&nbsp;
LABEL description=<span class="hljs-string">"This image emits a regular message on STDIN"</span>&nbsp;
COPY heartbeat.sh /entrypoint.sh&nbsp;
RUN <span class="hljs-keyword">chmod</span> +<span class="hljs-keyword">x</span> /entrypoint.sh&nbsp;
ENV HEARTBEATSTEP <span class="hljs-number">2</span>&nbsp;
ENTRYPOINT [<span class="hljs-string">"./entrypoint.sh"</span>]&nbsp;
CMD [<span class="hljs-string">"heartbeat"</span>]</code></pre>
          <p class="defaut">Si nous compilons ce <span class="courier11">Dockerfile</span>,
nous obtenons l’image correspondante avec le nom choisi, dans notre
cas <span class="courier11">repeater</span>&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP57.png" title="images/04EP57.png" src="IMAGES/04EP57.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Pour approfondir l’analyse de ce
qui s’est passé dans la commande, nous allons avoir
recours à une commande permettant d’afficher l’arborescence
des images. Cette commande,&nbsp;par le passé, a fait
partie de <span class="courier11">docker images</span>, sous la
forme d’une option <span class="courier11">--tree</span> qui
est désormais dépréciée depuis
longtemps. La page <a class="url" href="https://github.com/moby/moby/issues/1776" target="_blank">https://github.com/moby/moby/issues/1776</a> recommande
l’utilisation à la place d’une commande
externe,&nbsp;diffusée justement sous la forme d’un
conteneur&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript">docker run --rm -v /<span class="hljs-keyword">var</span>/run/docker.sock:<span class="hljs-regexp">/var/</span>run/docker.sock &nbsp;
nate/dockviz images -t</code></pre>
          <p class="defaut">Le fait que la commande ne fasse plus partie
de l’outil Docker lui-même et se base sur un conteneur
externe posera bien sûr problème en production,
quelle que soit la confiance qu’on puisse porter au propriétaire
du compte <span class="courier11">nate</span>. Le fait d’utiliser
une liaison de volume pour donner à ce conteneur l’accès
au socket permettant de piloter le démon Docker de la machine
nécessite également un haut degré de
confiance, que vous n’aurez peut-être pas sur
votre machine. Dans ce cas, le plus simple est de créer
une machine virtuelle ou une machine dans le cloud que vous pourrez
supprimer après quelques manipulations.</p>
          <p class="defaut">Ces précautions étant posées,
l’exécution de la commande nous permet de visionner
l’arborescence complète de l’image de notre exemple&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP58.png" title="images/04EP58.png" src="IMAGES/04EP58.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Cet affichage est riche d’enseignements. En
haut dans l’arborescence se trouvent les images intermédiaires
et celle, au sixième niveau, correspondant à l’image <span class="courier11">ubuntu</span> dans son tag <span class="courier11">latest</span>, sur laquelle nous avions basé l’image <span class="courier11">repeater</span>. À partir du septième
rang se trouvent huit niveaux d’images, sept étant intermédiaires
et la dernière correspondant à l’image <span class="courier11">repeater</span>.</p>
          <p class="defaut">Pour bien faire le lien entre les images intermédiaires
et les instructions de compilation, il peut être pertinent
de repasser le cas échéant sur l’ancien mode, en
utilisant la commande ci-dessous, déjà expliquée
auparavant&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript"><span class="hljs-keyword">export</span> DOCKER_BUILDKIT=<span class="hljs-number">0</span></code></pre>
          <p class="defaut">La commande <span class="courier11">docker
build</span> fait alors apparaître plus clairement les
neuf instructions et donc les neuf niveaux d’images dont nous parlons&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP59.png" title="images/04EP59.png" src="IMAGES/04EP59.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Ce nombre correspond au nombre d’étapes
du fichier <span class="courier11">Dockerfile</span>. Ce dernier
comprenait en effet une ligne <span class="courier11">FROM</span> (ce
qui explique pourquoi l’arborescence se branche sur la couche portant
l’étiquette <span class="courier11">ubuntu:latest</span> au moment
de la compilation, comme nous l’avions vu plus haut) ainsi que huit commandes <span class="courier11">LABEL</span> (trois fois), <span class="courier11">COPY</span>,&nbsp;<span class="courier11">RUN</span>, <span class="courier11">ENV</span>, <span class="courier11">ENTRYPOINT</span> et
enfin <span class="courier11">CMD</span> qui clôt la liste
et correspond donc à l’image finale portant l’étiquette <span class="courier11">repeater</span>, en version <span class="courier11">latest</span> puisque nous n’avons pas précisé autrement
et qu’il s’agit de qualificatif par défaut.</p>
          <p class="defaut">En enlevant la taille virtuelle pour faciliter
l’affichage et en rajoutant entre parenthèses les étapes
successives du <span class="courier11">Dockerfile</span>, nous
pouvons donc réécrire la sortie précédente
comme suit&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">├─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│ └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> Tags: ubuntu:latest (image utilisée par le FROM)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> (image issue de l’instruction LABEL)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> (image issue de l’instruction LABEL)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> (image issue de l’instruction LABEL)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> (image issue de l’instruction COPY)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> (image issue de l’instruction RUN)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> (image issue de l’instruction ENV)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> (image issue de l’instruction ENTRYPOINT)&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─67ef7467c4ae Tags: &nbsp;
jpgouigoux/repeater:latest (CMD et image résultant de la compilation)</code></pre>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">À propos de taille virtuelle,
justement, celle-ci correspond à la taille de l’image accompagnée
de toutes les images dont elle dépend. Il est donc logique qu’elle
ne fasse qu’augmenter au fur et à mesure qu’on descend
dans la liste. On constate d’ailleurs que sur notre exemple, elle
n’augmente quasiment pas (en fait, tellement peu que ce n’est pas
visible sur cet affichage), ce qui prouve que les dernières étapes
de création de l’image <span class="courier11">ubuntu</span> ainsi
que les commandes de construction de l’image <span class="courier11">repeater</span> ne
prennent que très peu de place dans les images générées.</p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle3">
          <h3 class="title">b. Anatomie d’une compilation d’image</h3>
          <p class="defaut">La raison pour laquelle nous parlons des images
intermédiaires est pour expliquer la puissance du cache.
Dans la section précédente, nous avons montré qu’un
cache était mis en œuvre par Docker pour éviter
de ramener, par exemple, l’image <span class="courier11">ubuntu</span> à chaque
fois qu’on instancie un conteneur basé dessus. Il se trouve
que le même mécanisme est mis en œuvre
pour chacune des images intermédiaires et permet donc de
bénéficier d’une performance accrue lors de la
compilation d’une image&nbsp;: toutes les étapes n’ayant
pas subi de changement n’ont aucune raison d’aboutir à une
image intermédiaire différente, et celle-ci est
donc récupérée dans le cache plutôt
que reconstruite par la commande <span class="courier11">docker
build</span>.</p>
          <p class="defaut">Là encore, le plus simple est de
montrer graphiquement l’effet d’une recompilation sur notre <span class="courier11">Dockerfile</span> modifié. Lorsque
nous avions compilé l’image <span class="courier11">repeater</span>,
nous avions obtenu la sortie suivante&nbsp;:</p>
          <pre class="programlisting"><code class="hljs shell">Sending build context to Docker daemon&nbsp;&nbsp;3.072kB&nbsp;
Step 1/9&nbsp;: FROM ubuntu:latest&nbsp;
<span class="hljs-meta">---&gt;</span> bb0eaf4eee00&nbsp;
Step 2/9&nbsp;: LABEL maintainer="jp.gouigoux@free.fr"&nbsp;
<span class="hljs-meta">---&gt;</span> Running in 0dcc18b687e2&nbsp;
Removing intermediate container 0dcc18b687e2&nbsp;
<span class="hljs-meta">---&gt;</span> 167463282d81&nbsp;
Step 3/9&nbsp;: LABEL version="1.0"&nbsp;
<span class="hljs-meta">---&gt;</span> Running in 6a355759f22a&nbsp;
Removing intermediate container 6a355759f22a&nbsp;
<span class="hljs-meta">---&gt;</span> 940a9b4fbc8a&nbsp;
Step 4/9&nbsp;: LABEL description="This image emits a regular message &nbsp;
on STDOUT"&nbsp;
<span class="hljs-meta">---&gt;</span> Running in 55b55d050504&nbsp;
Removing intermediate container 55b55d050504&nbsp;
<span class="hljs-meta">---&gt;</span> 9b7a8d40f1b2&nbsp;
Step 5/9&nbsp;: COPY heartbeat.sh /entrypoint.sh&nbsp;
<span class="hljs-meta">---&gt;</span> ac5aa49aac38&nbsp;
Step 6/9&nbsp;: RUN chmod +x /entrypoint.sh&nbsp;
<span class="hljs-meta">---&gt;</span> Running in 8f380fb5d47d&nbsp;
Removing intermediate container 8f380fb5d47d&nbsp;
<span class="hljs-meta">---&gt;</span> 7bdef76d6912&nbsp;
Step 7/9&nbsp;: ENV HEARTBEATSTEP ${HEARTBEATSTEPDEFAULT}&nbsp;
<span class="hljs-meta">---&gt;</span> Running in 0cdff1fa5b42&nbsp;
Removing intermediate container 0cdff1fa5b42&nbsp;
<span class="hljs-meta">---&gt;</span> 182c4ab6003a&nbsp;
Step 8/9&nbsp;: ENTRYPOINT ["./entrypoint.sh"]&nbsp;
<span class="hljs-meta">---&gt;</span> Running in cb7282b15745&nbsp;
Removing intermediate container cb7282b15745&nbsp;
<span class="hljs-meta">---&gt;</span> 6ad4ed7cb559&nbsp;
Step 9/9&nbsp;: CMD ["heartbeat"]&nbsp;
<span class="hljs-meta">---&gt;</span> Running in 7a47087eaf08&nbsp;
Removing intermediate container 7a47087eaf08&nbsp;
<span class="hljs-meta">---&gt;</span> 8438cab83bce&nbsp;
Successfully built 8438cab83bce&nbsp;
Successfully tagged jpgouigoux/repeater:latest</code></pre>
          <p class="defaut">Cet affichage nous renseigne sur la façon
dont Docker procède pour compiler une image. À chaque
pas (<span class="italic">step</span>, en anglais), Docker&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1">démarre un
conteneur temporaire (à l’étape 2, il a pour identifiant <span class="courier11">0dcc18b687e2</span>),&nbsp;</p>
              </li>
              <li class="liste1">
                <p class="liste1">lance la commande sur ce conteneur,</p>
              </li>
              <li class="liste1">
                <p class="liste1">effectue une opération
de commit dans une image intermédiaire dont il donne le
code (toujours à l’étape 2, c’est cette fois-ci
le code <span class="courier11">167463282d81</span>),</p>
              </li>
              <li class="liste1">
                <p class="liste1">supprime le conteneur intermédiaire
(message <span class="courier11">Removing intermediate container
0dcc18b687e2</span> dans le cas de l’étape 2),</p>
              </li>
              <li class="liste1">
                <p class="liste1">passe à l’étape
suivante et reproduit le même processus, en se basant cette fois
sur un conteneur instancié depuis l’image intermédiaire
précédente,</p>
              </li>
              <li class="liste1">
                <p class="liste1">arrivé à la dernière étape,
Docker étiquette l’image finale et annonce la réussite
de l’opération en rappelant le code de l’image générée,
dans notre cas <span class="courier11">8438cab83bce</span>.</p>
              </li>
            </ul>
          </div>
        </div>
        <div class="sect3" id="refTitle4">
          <h3 class="title">c. Analyse d’une modification du Dockerfile</h3>
          <p class="defaut">Imaginons maintenant que nous souhaitions
changer l’intervalle de temps par défaut de notre image <span class="courier11">repeater</span>, en le ramenant à une
seconde. Nous modifierions le <span class="courier11">Dockerfile</span>&nbsp;comme
suit (seule la ligne commençant par <span class="courier11">ENV</span> est impactée)&nbsp;:</p>
          <pre class="programlisting"><code class="hljs perl">FROM ubuntu:latest&nbsp;
LABEL maintainer=<span class="hljs-string">"jp.gouigoux@free.fr"</span>&nbsp;
LABEL version=<span class="hljs-string">"1.0"</span>&nbsp;
LABEL description=<span class="hljs-string">"This image emits a regular message on STDIN"</span>&nbsp;
COPY heartbeat.sh /entrypoint.sh&nbsp;
RUN <span class="hljs-keyword">chmod</span> +<span class="hljs-keyword">x</span> /entrypoint.sh<b>&nbsp;
ENV HEARTBEATSTEP <span class="hljs-number">1</span></b>&nbsp;
ENTRYPOINT [<span class="hljs-string">"./entrypoint.sh"</span>]&nbsp;
CMD [<span class="hljs-string">"heartbeat"</span>]</code></pre>
          <p class="defaut">Le fait de compiler l’image produirait l’affichage
suivant&nbsp;:</p>
          <pre class="programlisting"><code class="hljs sql">Sending build context to Docker daemon&nbsp;&nbsp;3.072kB&nbsp;
Step 1/9&nbsp;: FROM ubuntu:latest&nbsp;
<span class="hljs-comment">---&gt; bb0eaf4eee00&nbsp;</span>
Step 2/9&nbsp;: LABEL maintainer="jp.gouigoux@free.fr"&nbsp;
<span class="hljs-comment">---&gt; Using cache&nbsp;</span>
<span class="hljs-comment">---&gt; 167463282d81&nbsp;</span>
Step 3/9&nbsp;: LABEL version="1.0"&nbsp;
<span class="hljs-comment">---&gt; Using cache&nbsp;</span>
<span class="hljs-comment">---&gt; 940a9b4fbc8a&nbsp;</span>
Step 4/9&nbsp;: LABEL description="This image emits a regular message &nbsp;
on STDOUT"&nbsp;
<span class="hljs-comment">---&gt; Using cache&nbsp;</span>
<span class="hljs-comment">---&gt; 9b7a8d40f1b2&nbsp;</span>
Step 5/9&nbsp;: COPY heartbeat.sh /entrypoint.sh&nbsp;
<span class="hljs-comment">---&gt; Using cache&nbsp;</span>
<span class="hljs-comment">---&gt; ac5aa49aac38&nbsp;</span>
Step 6/9&nbsp;: RUN chmod +x /entrypoint.sh&nbsp;
<span class="hljs-comment">---&gt; Using cache&nbsp;</span>
<span class="hljs-comment">---&gt; 7bdef76d6912&nbsp;</span>
Step 7/9&nbsp;: ENV HEARTBEATSTEP 1&nbsp;
<span class="hljs-comment">---&gt; Running in a8bb232fe4f1&nbsp;</span>
Removing intermediate container a8bb232fe4f1&nbsp;
<span class="hljs-comment">---&gt; 5e34e4670c5a&nbsp;</span>
Step 8/9&nbsp;: ENTRYPOINT ["./entrypoint.sh"]&nbsp;
<span class="hljs-comment">---&gt; Running in 91cceed9b672&nbsp;</span>
Removing intermediate container 91cceed9b672&nbsp;
<span class="hljs-comment">---&gt; ee04e13f0bbb&nbsp;</span>
Step 9/9&nbsp;: CMD ["heartbeat"]&nbsp;
<span class="hljs-comment">---&gt; Running in 1b9f807a0ffc&nbsp;</span>
Removing intermediate container 1b9f807a0ffc&nbsp;
<span class="hljs-comment">---&gt; 174c5dd13c16&nbsp;</span>
Successfully built 174c5dd13c16&nbsp;
Successfully tagged jpgouigoux/repeater:latest</code></pre>
          <p class="defaut">Si nous nous intéressons au premier
pas de la compilation proprement dite (step 2 dans la sortie ci-dessus,
le step 1 correspondant à la récupération
de l’image de base), le message de lancement d’un conteneur
intermédiaire est remplacé par <span class="courier11">Using cache</span>. Docker a repéré que
rien n’a changé et il décide donc d’utiliser son
cache sur l’image intermédiaire. On voit d’ailleurs que l’identifiant
résultant pour ce pas est le même, à savoir
dans notre exemple <span class="courier11">167463282d81</span>.</p>
          <p class="defaut">Mais sur le pas n°7 (qui correspond à la
commande <span class="courier11">ENV</span> que nous avons modifiée),
le cache n’est logiquement plus utilisable, et il y a alors réelle
recompilation, qui aboutit à un identifiant différent
de celui que nous avions auparavant pour cette même étape.</p>
          <p class="defaut">Logiquement, tous les pas de compilation suivants
sont impactés&nbsp;: puisque l’image résultant&nbsp;du
pas n°7 a changé, le pas n°8 ne peut pas utiliser son cache, doit
recompiler son image qui sera différente et ainsi de suite
jusqu’à aboutir à une image finale (étiquetée <span class="courier11">repeater:latest</span>) avec un identifiant
différent de la première compilation, en l’occurrence <span class="courier11">174c5dd13c16</span> au lieu de <span class="courier11">8438cab83bce</span>, ce qui marque bien d’ailleurs
que son comportement final n’est plus le même (intervalle
d’une seconde en dur au lieu d’une valeur paramétrable à la
compilation sur la forme précédente du <span class="courier11">Dockerfile</span>).&nbsp;</p>
          <p class="defaut">L’utilisation de la même commande
que plus haut montre la nouvelle arborescence, qui bifurque à la
septième étape en dessous de l’image de base <span class="courier11">ubuntu:latest</span>, et avec l’étiquette <span class="courier11">repeater:latest</span> sur les nouveaux identifiants
d’images (les informations sur la taille virtuelle ont là encore été enlevées
et les deux identifiants d’image finale ont été mis
en gras pour faciliter l’analyse)&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">├─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│ └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─bb0eaf4eee00 <b>Tags: ubuntu:latest</b>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├─167463282d81 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │ └─940a9b4fbc8a &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp; └─9b7a8d40f1b2 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp; └─ac5aa49aac38 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─7bdef76d6912 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├─182c4ab6003a &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │ └─6ad4ed7cb559 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp; └─8438cab83bce <b>(image désormais "orpheline")</b>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─5e34e4670c5a &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─ee04e13f0bbb &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─174c5dd13c16 <b>Tags: jpgouigoux/repeater:latest</b>&nbsp;
└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
&nbsp;&nbsp;└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;└─93b5259c1e18 Tags: nate/dockviz:latest</code></pre>
          <p class="defaut">Une des deux branches, en l’occurrence la
première dans l’ordre de l’affichage, se retrouve difficilement
accessible, car aucune étiquette ne pointe dessus. Ce qui
se manifeste par un affichage moins élégant sur
une commande <span class="courier11">docker images</span>&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP60.png" title="images/04EP60.png" src="IMAGES/04EP60.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Toutefois, elle est toujours bien présente,
ce qui permet à des éventuels usages de continuer à se
baser sur cette image et ne pas prendre de risque de pointer sur
une nouvelle version qui modifierait le comportement de manière
non maîtrisée.</p>
          <p class="defaut">La commande <span class="courier11">docker
system prune</span> montrée plus haut permet de faire le
ménage dans ce type d’images qui sont alors difficilement
utilisables.</p>
        </div>
        <div class="sect3" id="refTitle5">
          <h3 class="title">d. Gestion correcte des étiquettes</h3>
          <p class="defaut">Cette notion d’image orpheline que nous venons
de décrire est justement la raison pour laquelle il est
recommandé de toujours donner un numéro de version
explicite lors de la compilation, et de déplacer ensuite éventuellement l’étiquette <span class="courier11">latest</span> par la commande <span class="courier11">tag</span>, en fonction de la politique d’affectation
de cette étiquette. Dans notre cas, nous aurions pu nous
en sortir en corrigeant l’ancienne entrée et en lui donnant
la version 1.0 par la commande <span class="courier11">docker tag
8438cab83bce jpgouigoux/repeater:1.0</span>.</p>
          <p class="defaut">Et si l’on tient à obtenir un état
impeccable, une autre commande <span class="courier11">docker tag</span><span class="courier11">repeater:latest repetiteur:2.0</span> permettra
d’affecter une seconde étiquette à l’image associée
pour l’instant seulement à <span class="courier11">repeater:latest</span>.
L’arborescence sera alors identique à celle que nous aurions obtenue
si nous avions compilé dès le début avec
les bons numéros de versions&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">├─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│ └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─bb0eaf4eee00 Tags: ubuntu:latest&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─167463282d81 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─940a9b4fbc8a &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─9b7a8d40f1b2 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─ac5aa49aac38 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─7bdef76d6912 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├─182c4ab6003a&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │ └─6ad4ed7cb559&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp; └─8438cab83bce <b>Tags: jpgouigoux/repeater:1.0</b>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─5e34e4670c5a &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─ee04e13f0bbb &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─174c5dd13c16 <b>Tags: &nbsp;
jpgouigoux/repeater:2.0, jpgouigoux/repeater:latest</b></code></pre>
          <p class="defaut">L’enchaînement recommandé de
compilation des images est le suivant&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1"><span class="courier11">docker
build -t repetiteur:1.0</span></p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">docker
tag repetiteur:1.0 repetiteur:latest</span></p>
              </li>
              <li class="liste1">
                <p class="liste1">modification du <span class="courier11">Dockerfile</span></p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">docker
build -t repetiteur:1.0</span></p>
              </li>
              <li class="liste1">
                <p class="liste1"><span class="courier11">docker
tag -f repetiteur:1.0 repetiteur:latest</span></p>
              </li>
            </ul>
          </div>
          <p class="defaut">L’option <span class="courier11">-f</span> est
nécessaire pour la dernière commande, car l’étiquette <span class="courier11">latest</span> étant déjà affectée à l’image étiquetée
1.0, il est nécessaire de forcer le déplacement
de l’étiquette <span class="courier11">latest</span> vers
une autre image du même dépôt (<span class="courier11">repeater</span>). Il aurait également été possible
de supprimer le tag <span class="courier11">latest</span> de l’image en
version 1.0 en utilisant la commande <span class="courier11">docker
rmi</span>, puis de l’affecter sans qu’il soit alors nécessaire
de forcer le déplacement par l’option <span class="courier11">-f</span>.</p>
          <p class="defaut">Lorsque la commande <span class="courier11">rmi</span> est
utilisée sur une étiquette alors que l’image en contient
d’autres, le message résultant indique seulement le "désétiquetage".</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP61.png" title="images/04EP61.png" src="IMAGES/04EP61.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Il peut paraître étrange
d’appeler une commande <span class="courier11">rmi</span> (abréviation
de <span class="courier11">remove image</span>, soit supprimer
l’image, en anglais) alors que l’image reste en place, mais la suppression
de l’image et donc de toutes les étiquettes, alors qu’on
n’en a précisé qu’une seule dans la commande,
serait encore plus déroutante à l’usage.</p>
            </div>
          </div>
          <p class="defaut">Par contre, lorsque la commande <span class="courier11">rmi</span> est utilisée sur la dernière étiquette d’une
image, celle-ci est effectivement supprimée et, à moins
que l’option <span class="courier11">--no-prune</span> ne soit
utilisée, toutes les images intermédiaires le
sont également. Par exemple, après avoir supprimé le
tag <span class="courier11">latest</span> comme montré ci-dessus, nous
pouvons également supprimer le tag <span class="courier11">repeater:2.0</span>,
avec la fameuse option&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP62.png" title="images/04EP62.png" src="IMAGES/04EP62.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Le message est clair sur le fait qu’une seule
image a été supprimée (nous avions jusqu’à maintenant
utilisé les identifiants courts, mais celui affiché correspond à la
version longue). L’arborescence résultante serait alors
comme suit&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">├─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│ └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span> &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─bb0eaf4eee00 Tags: ubuntu:latest&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─167463282d81 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─940a9b4fbc8a &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─9b7a8d40f1b2 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─ac5aa49aac38 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─7bdef76d6912 &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├─182c4ab6003a&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │ └─6ad4ed7cb559&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp; └─8438cab83bce Tags: jpgouigoux/repeater:1.0&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─5e34e4670c5a &nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─ee04e13f0bbb</code></pre>
          <p class="defaut">Et nous nous retrouvons à nouveau
avec une entrée non nommée dans la liste des images
finales (les non intermédiaires, c’est-à-dire
celles qui correspondent à un nœud final dans
l’arbre ou bien qui ont reçu une étiquette)&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP63.png" title="images/04EP63.png" src="IMAGES/04EP63.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Il faut alors supprimer cette image par son
identifiant pour remettre les choses en ordre&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP64.png" title="images/04EP64.png" src="IMAGES/04EP64.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Pour revenir à zéro, nous
supprimons ensuite le tag <span class="courier11">repeater:1.0</span>,
en prenant bien garde cette fois de ne pas utiliser l’option <span class="courier11">--no-prune</span> (dont l’utilité en
situation réelle n’est pas évidente), ce qui aboutit
bien à la suppression des huit images intermédiaires
en plus de l’image correspondant à la première version
de notre exemple&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP65.png" title="images/04EP65.png" src="IMAGES/04EP65.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
        </div>
        <div class="sect3" id="refTitle6">
          <h3 class="title">e. Invalidation du cache par modification de l’image
de base</h3>
          <p class="defaut">Nous avons vu plus haut que le mécanisme
de cache était évidemment désactivé dès
qu’une modification dans le fichier <span class="courier11">Dockerfile</span> était
opérée. Ceci est vrai pour n’importe quelle modification,
y compris le simple ajout d’un espace ne changeant en rien la signification
de la commande concernée.</p>
          <p class="defaut">La décision d’invalidation du cache
(il s’agit de l’expression consacrée) comporte quelques
autres cas.</p>
          <p class="defaut">Le premier survient lorsque l’image de base
pointée par l’étiquette dans le <span class="courier11">FROM</span> n’est plus la même (on
ne peut pas vraiment dire qu’elle a changé, car une image
est, comme nous l’avons vu, immuable&nbsp;: seule l’étiquette
se déplace vers une autre image, ce qui donne l’impression
que celle-ci a changé). Bien sûr, tout l’intérêt
d’utiliser des versions dans les images est de stabiliser leur contenu
de façon à éviter d’impacter les personnes
les utilisant. On ne devrait donc jamais livrer une image modifiée
sous un numéro de version déjà utilisé. Mais
rien ne l’empêche, et il est intéressant de savoir
que cela aboutit à une recompilation de l’image basée
sur celle qui a évolué.</p>
          <p class="defaut">Ce premier cas est très instructif
sur le fonctionnement des images. Nous allons donc le détailler&nbsp;:</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Supprimez toutes les références à <span class="courier11">repeater</span> s’il en reste (normalement,
la fin de la section précédente a permis de faire
le ménage).</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Placez-vous dans le répertoire <span class="courier11">repeater</span> contenant le <span class="courier11">Dockerfile</span> utilisé comme
exemple jusqu’à maintenant.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Compilez l’image en lui donnant une étiquette <span class="courier11">repeater:1.0</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Créez un autre répertoire
au même niveau que <span class="courier11">repeater</span> (surtout
pas à l’intérieur de ce même répertoire)
et placez-vous dedans. Nous l’appelons pour notre exemple <span class="courier11">dependance</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Créez un fichier <span class="courier11">Dockerfile</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Ajoutez-lui les lignes suivantes&nbsp;:</p>
          </div>
          <pre class="programlisting"><code class="hljs vbnet"><span class="hljs-keyword">FROM</span> repeater:<span class="hljs-number">1.0</span>&nbsp;
ENV MESSAGEDEFAUT heartbeat</code></pre>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Sauvegardez le fichier.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Compilez ce <span class="courier11">Dockerfile</span> sous
le nom d’image <span class="courier11">dependance:1.0</span>.</p>
          </div>
          <p class="defaut">L’arborescence des images se présente
comme suit (les informations de taille virtuelle étant
désormais systématiquement supprimées)&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
&nbsp;&nbsp;└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span><b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─bb0eaf4eee00 Tags: ubuntu:latest</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─855909189aea&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─19b6945bbe12&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─5dbfa8a6c3d8&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─e062be0f030b&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─9a7cf02b0878&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─13b406253ace&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─796c9a5af183<b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─b5b856c819e2 Tags: repeater:1.0&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─71205df6b6de Tags: dependance:1.0</b></code></pre>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Revenez dans le répertoire <span class="courier11">repeater</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Procédez à une modification
quelconque sur le fichier <span class="courier11">Dockerfile</span>,
par exemple en changeant l’intervalle par défaut.</p>
          </div>
          <p class="defaut">C’est à ce moment que nous devrions
compiler l’image sous un numéro de version différent,
en utilisant par exemple le tag <span class="courier11">repetiteur:1.1</span>.
Mais nous allons enfreindre les règles de bonne gestion
des versions en créant une version 1.0 différente
de celle déjà publiée. Conscients que
la simple compilation avec le même numéro aboutirait - comme
précédemment - à des identifiants
sans étiquette dans la liste, nous imaginons supprimer
l’image 1.0&nbsp;:</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Entrez la commande <span class="courier11">docker
rmi repeater:1.0</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Constatez que l’image n’est pas supprimée,
mais que seule l’étiquette est enlevée&nbsp;:</p>
          </div>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP66.png" title="images/04EP66.png" src="IMAGES/04EP66.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Que s’est-il passé&nbsp;? Tout
simplement, l’image <span class="courier11">dependance:1.0</span> était
en dessous dans la liste, et la commande <span class="courier11">rmi</span> ne
peut donc pas aboutir à une suppression de l’image désignée
par l’étiquette <span class="courier11">repeater:1.0</span>,
car une autre image l’utilise. Docker fait donc bien les choses
et se contente de supprimer l’étiquette.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Notons que si nous avions procédé autrement,
en recompilant directement une nouvelle image étiquetée <span class="courier11">repeater:1.0</span>, l’arborescence aurait
montré l’image <span class="courier11">dependance:1.0</span> branchée
sous la partie de l’arborescence sans étiquette. La version <span class="courier11">repeater:1.0</span> serait passée
sur une autre image, mais <span class="courier11">dependance:1.0</span> serait
toujours branchée sur son image d’origine. Encore une fois,
et comme pour l’exemple précédent sur la restauration
d’une archive, Docker fait le nécessaire pour que les images
soient parfaitement immuables et continuent dans tous les cas à fonctionner
de la même manière.</p>
            </div>
          </div>
          <p class="defaut">L’arborescence montre que l’image <span class="courier11">b5b856c819e2</span> est toujours là,
même si le tag a disparu, ce qui permet à l’image <span class="courier11">71205df6b6de</span> de ne pas se retrouver orpheline&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
&nbsp;&nbsp;└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span><b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─bb0eaf4eee00 Tags: ubuntu:latest</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─855909189aea&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─19b6945bbe12&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─5dbfa8a6c3d8&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─e062be0f030b&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─9a7cf02b0878&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─13b406253ace&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─796c9a5af183 <b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─b5b856c819e2&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─71205df6b6de Tags: dependance:1.0</b></code></pre>
          <p class="defaut">Nous allons maintenant recompiler l’image <span class="courier11">repeater</span> modifiée en lui
donnant la version 1.0 (encore une fois, ce n’est pas une bonne
façon de gérer les versions, nous réalisons
cette infraction pour montrer le comportement du cache en cas de
modification de l’image de base).</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Vérifiez que vous êtes toujours
dans le répertoire <span class="courier11">repeater</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Lancez la commande de compilation <span class="courier11">docker build -t repetiteur:1.0.</span> (ne
pas oublier le point, signalant le répertoire local).</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Vérifiez que le cache est bien utilisé jusqu’à la
commande que vous aurez modifiée.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Lancez la commande montrée plus haut
pour obtenir l’arborescence des images.</p>
          </div>
          <p class="defaut">Logiquement, nous obtenons une bifurcation
avec une première branche qui est maintenant finie par <span class="courier11">repeater:1.0</span>, alors que la seconde
branche se termine par <span class="courier11">dependance:1.0</span>,
pour l’instant toujours fondée sur l’image de base à partir
de laquelle&nbsp;elle a été compilée,
et qui n’est plus désormais repérée que
par son identifiant <span class="courier11">b5b856c819e2</span>&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">├─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│ └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─bb0eaf4eee00 Tags: ubuntu:latest&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─855909189aea&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─19b6945bbe12&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─5dbfa8a6c3d8&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─e062be0f030b&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─9a7cf02b0878&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├─2995b2592313&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │ └─7041412372d3&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp; └─63692b92bbab&nbsp;<b>Tags: repeater:1.0</b>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─13b406253ace&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─796c9a5af183&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─b5b856c819e2&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─71205df6b6de&nbsp;<b>Tags: dependance:1.0</b></code></pre>
          <p class="defaut">Nous allons maintenant recompiler l’image <span class="courier11">dependance</span>, cette fois de manière
propre, c’est-à-dire en faisant évoluer son numéro
de version en conséquence.</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Positionnez-vous dans le répertoire <span class="courier11">dependance</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Inutile de procéder à une
modification du fichier <span class="courier11">Dockerfile</span>.
Comme l’image de base a été modifiée,
une recompilation sera opérée de toute façon.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Compilez l’image sous un numéro de
version <span class="courier11">1.1</span>.</p>
          </div>
          <p class="defaut">La sortie montre que la compilation se fait
sans cache, et en utilisant l’image à jour de <span class="courier11">repeater:1.0</span> (l’identifiant utilisé est
bien <span class="courier11">63692b92bbab</span>)&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP67.png" title="images/04EP67.png" src="IMAGES/04EP67.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Et l’arborescence est bien conforme à ce
que nous attendons, avec <span class="courier11">dependance:1.1</span> dépendant
de <span class="courier11">repeater:1.0</span> et <span class="courier11">dependance:1.0</span> dépendant
de l’image <span class="courier11">b5b856c819e2</span>, qui n’a
plus d’étiquette&nbsp;:</p>
          <pre class="programlisting"><code class="hljs xml">├─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│ └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp; └─<span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─bb0eaf4eee00 Tags: ubuntu:latest&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─855909189aea&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─19b6945bbe12&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─5dbfa8a6c3d8&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─e062be0f030b&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─9a7cf02b0878&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├─13b406253ace&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │ └─796c9a5af183&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp; └─b5b856c819e2&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp; └─71205df6b6de&nbsp;<b>Tags: dependance:1.0</b>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─2995b2592313&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─7041412372d3<b>&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─63692b92bbab Tags: repeater:1.0&nbsp;
│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─b458be9d2bb6 Tags: dependance:1.1</b></code></pre>
          <p class="defaut">En plus de nous montrer que le cache était
bien invalidé lors d’une modification de l’image pointée
par le <span class="courier11">FROM</span> (même si cela
ne devrait jamais arriver si la gestion des versions est correcte),
cet exemple a pour vertu de nous montrer les fonctionnalités
mises en œuvre par Docker pour que les images restent bien
immuables. Encore une fois, ceci est une caractéristique
fondamentale de Docker&nbsp;: la garantie que tel conteneur
en sortie d’usine de développement fonctionnera de la même
manière en production, sur un serveur local, dans un environnement
de type cloud, etc.</p>
        </div>
        <div class="sect3" id="refTitle7">
          <h3 class="title">f. Invalidation du cache par modification du contexte<var style="display:none"> Contexte</var></h3>
          <p class="defaut">Les deux cas d’invalidation du cache que nous
avons vus pour l’instant sont assez logiques&nbsp;: si l’image
de base évolue, il faut recompiler&nbsp;; si une commande du <span class="courier11">Dockerfile</span> change, il faut recompiler.
Mais il existe un cas un peu moins évident, et qui est
pourtant essentiel&nbsp;: il s’agit de l’invalidation du cache par
modification du contexte.</p>
          <p class="defaut">Plus haut dans le présent chapitre,
nous avons expliqué la notion de contexte, en faisant remarquer
que tout le répertoire courant était mis à disposition
de l’opération de compilation. Dans notre exemple, le fichier <span class="courier11">heartbeat.sh</span> se retrouve ainsi disponible
pour l’opération <span class="courier11">COPY</span>.
Or, que devrait-il se passer si le fichier <span class="courier11">heartbeat.sh</span> est
modifié&nbsp;? Si l’on s’en tient à la stricte
application de l’invalidation de cache telle que nous la connaissons
jusqu’à maintenant, ni l’image de base ni le <span class="courier11">Dockerfile</span> n’ont changé,
donc l’impact sur l’image résultante
devrait être nul. Mais la logique voudrait que, ce fichier
essentiel au comportement de notre image ayant changé,
la recompilation en tienne compte.</p>
          <p class="defaut">C’est bien ce qui se passe, et nous allons
le démontrer par les manipulations suivantes&nbsp;:</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Supprimez toutes les images ayant servi précédemment.
Si vous avez suivi les exemples jusqu’à maintenant, une
commande <span class="courier11">docker rmi dependance:1.0 dependance:1.1
repeater:1.0</span> suffit.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Placez-vous dans le répertoire <span class="courier11">repeater</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Compilez l’image une première fois
sous le tag <span class="courier11">repeater:1.0</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Modifiez simplement le fichier <span class="courier11">heartbeat.sh</span>, en plaçant
par exemple une ligne vide au milieu du fichier.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Compilez à nouveau l’image, cette
fois sous le tag <span class="courier11">repeater:1.1</span>.</p>
          </div>
          <p class="defaut">La sortie, qui doit être proche de
celle ci-dessous, montre que les premières étapes
ont bien utilisé le cache, mais que l’étape n°5,
qui correspond à la commande <span class="courier11">COPY</span>,
n’a pas pu l’utiliser&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP68.png" title="images/04EP68.png" src="IMAGES/04EP68.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Docker a détecté que le
contexte de compilation (le contenu recopié du répertoire
courant, en l’occurrence notre fichier <span class="courier11">heartbeat.sh</span> qui était
posé au même emplacement que le fichier <span class="courier11">Dockerfile</span>) a changé, et
a donc invalidé le cache sur la commande <span class="courier11">COPY</span>. Il en aurait d’ailleurs été de
même sur la commande <span class="courier11">ADD</span>,
très proche dans son fonctionnement de <span class="courier11">COPY</span>.
Notez qu’il n’a pas été nécessaire de
procéder à un changement de nom du fichier&nbsp;:
c’est bien la détection du changement de son contenu qui
a abouti à la recompilation d’une partie des images intermédiaires.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">C’est bien l’émission de
ce contexte qui est pointée au début des messages affichés
lors de la compilation (ligne <span class="courier11">Sending build
context to Docker daemon</span>, suivi de la taille du contexte
passé à l’application Docker).</p>
            </div>
          </div>
          <p class="defaut">À ce jour, les trois cas cités
sont les seuls qui aboutissent à une invalidation de cache.
Nous allons voir dans la section suivante en quoi cela nécessite
de faire attention pour certains usages.</p>
        </div>
      </div>
      <div class="sect2" id="refTitle8">
        <h2 class="title">3. Conséquences sur l’écriture des
Dockerfile</h2>
        <div class="sect3" id="refTitle9">
          <h3 class="title">a. Le problème sur les opérations non
idempotentes</h3>
          <p class="defaut">Le problème se pose sur les commandes
Docker qui ne sont pas idempotentes. Une commande idempotente est
une opération qui aboutit systématiquement au
même résultat lorsqu’elle est lancée
dans le même contexte. Par exemple, l’affectation d’une
variable d’environnement par le <span class="courier11">Dockerfile</span> est idempotente
car elle produira le même résultat à chaque
fois, à savoir créer une variable d’environnement
avec une valeur&nbsp;donnée dans le conteneur utilisant
l’image générée. À l’inverse,
la commande <span class="courier11">date</span> est un exemple
canonique d’opération non idempotente, car en fonction
du moment&nbsp;où on l’appelle, le résultat
sera différent.</p>
          <p class="defaut">Quelle est la conséquence pour nos
fichiers descriptifs d’images Docker et leur compilation&nbsp;?
Pour bien comprendre le problème, prenons l’exemple de
commande non idempotente au pied de la lettre et créons
une image dépendant de la commande <span class="courier11">date</span>.</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Créez un répertoire <span class="courier11">testcache</span> n’importe où sauf à l’intérieur
d’un répertoire contenant un fichier <span class="courier11">Dockerfile</span>.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Placez-vous dans ce répertoire.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Créez un fichier <span class="courier11">Dockerfile</span> qui
contiendra le contenu suivant&nbsp;:</p>
          </div>
          <pre class="programlisting"><code class="hljs vbnet"><span class="hljs-keyword">FROM</span> ubuntu:latest&nbsp;
RUN <span class="hljs-built_in">date</span> +%N &gt; /tmp/moment&nbsp;
ENTRYPOINT [<span class="hljs-string">"more"</span>]&nbsp;
CMD [<span class="hljs-string">"/tmp/moment"</span>]</code></pre>
          <p class="defaut">L’image ne fera que stocker le nombre de nanosecondes
correspondant au moment présent dans un fichier et afficher
le contenu de celui-ci lors de l’instanciation d’un conteneur.</p>
          <p class="defaut">La compilation de l’image devrait donner un
résultat comme suit&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP69.png" title="images/04EP69.png" src="IMAGES/04EP69.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Et si nous exécutons un premier conteneur,
le résultat renverra un nombre à neuf chiffres
d’aspect aléatoire&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP70.png" title="images/04EP70.png" src="IMAGES/04EP70.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Regardons maintenant ce que va donner une
recompilation du <span class="courier11">Dockerfile</span>.</p>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Supprimez le conteneur lancé précédemment.</p>
          </div>
          <div class="manip">
            <p><span class="icon-manip">&nbsp;</span>Lancez à nouveau la compilation du <span class="courier11">Dockerfile</span>.</p>
          </div>
          <p class="defaut">La compilation devrait montrer que les trois étapes
utilisent le cache&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP71.png" title="images/04EP71.png" src="IMAGES/04EP71.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Et logiquement, si nous lançons un
second conteneur, nous verrons donc le même résultat&nbsp;pour
le retour de la commande <span class="courier11">date</span>, bien
que l’identifiant du conteneur montre que nous sommes sur une autre
instance&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP72.png" title="images/04EP72.png" src="IMAGES/04EP72.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Ainsi, contrairement aux commandes <span class="courier11">COPY</span> et <span class="courier11">ADD</span> qui
peuvent résulter en une invalidation de cache si le contexte
changé, la commande <span class="courier11">RUN</span> non
modifiée est systématiquement prise depuis le
cache, quand bien même son exécution peut aboutir à un
comportement différent de l’image.</p>
          <p class="defaut">Si nous extrapolons ce comportement sur des
commandes plus industrielles et réalisons un appel de <span class="courier11">apt-get update</span>, par exemple, au lieu
de notre commande artificielle de stockage d’une information de
date, les conséquences sont plus gênantes. En
effet, <span class="courier11">apt-get update</span> a pour but
de mettre à jour les dépôts dans lesquels
Ubuntu va chercher les mises à jour des applicatifs ou du
système. La mise en cache de cette commande aura pour conséquence
que lors de toutes les compilations suivant la première,
la commande ne sera pas exécutée, mais que son
résultat sera pris dans le cache des images. Les mises à jour
les plus récentes des paquets Ubuntu seront alors ignorées.
On imagine les conséquences désastreuses de la
non-prise en compte d’un patch urgent de sécurité...</p>
          <p class="defaut">De la même manière, un <span class="courier11">Dockerfile</span> qui lance une commande
de type <span class="courier11">git clone [adresse du
dépôt]</span> retrouve lors de la première
compilation le contenu du dépôt Git associé,
mais reste ensuite bloqué sur cette version du code, alors
que le comportement désiré est que chaque compilation
prenne la version du code à jour. Il est également
courant de devoir télécharger des scripts ou des
contenus dans un <span class="courier11">Dockerfile</span>, typiquement
en utilisant la commande <span class="courier11">curl</span>. Ces
opérations sont soumises à la même problématique.</p>
        </div>
        <div class="sect3" id="refTitle10">
          <h3 class="title">b. Contournement du problème de cache</h3>
          <p class="defaut">L’approche la plus directe pour régler
ces problèmes consiste à compiler l’image avec
l’option <span class="courier11">--no-cache</span>, ce qui force
l’invalidation de tous les niveaux de cache.</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP73.png" title="images/04EP73.png" src="IMAGES/04EP73.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Un test rapide permet de vérifier
que le comportement a bien changé, cette fois&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP74.png" title="images/04EP74.png" src="IMAGES/04EP74.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">L’approche de désactivation complète
du cache n’est pas particulièrement élégante,
et surtout, elle nécessite (sauf si l’opération
est automatisée) que la personne qui compile pense bien à utiliser
l’option. Il est également facile de passer à côté de
l’information comme quoi le cache a été utilisé,
ou tout simplement de ne plus se rappeler que le cache posait un
problème pour cette image en particulier. Enfin, le temps
de compilation de l’image n’est jamais réduit, ce qui peut être
pénalisant dans un processus très itératif
de développement, par exemple.</p>
          <p class="defaut">Dans certains cas, l’utilisation des numéros
de versions pour les contenus peut nous aider, par exemple si une
commande <span class="courier11">git checkout</span> est réalisée
après la commande <span class="courier11">git clone</span>.
Prenons l’exemple d’un fichier <span class="courier11">Dockerfile</span> comme
suit&nbsp;:</p>
          <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">FROM</span> <span class="hljs-selector-tag">ubuntu</span><span class="hljs-selector-pseudo">:trusty</span>&nbsp;
<span class="hljs-selector-tag">RUN</span> <span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">clone</span> <span class="hljs-selector-attr">[adresse du dépôt]</span>&nbsp;
<span class="hljs-selector-tag">WORKDIR</span> <span class="hljs-selector-attr">[répertoire récupéré]</span>&nbsp;
<span class="hljs-selector-tag">RUN</span> <span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">checkout</span> <span class="hljs-selector-tag">v1</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span>&nbsp;
<span class="hljs-selector-tag">RUN</span> <span class="hljs-selector-attr">[opération de compilation]</span></code></pre>
          <p class="defaut">Le fait de changer la version de la quatrième
ligne va bien invalider le cache. Le problème est que toutes
les opérations en aval seront réalisées à nouveau,
mais pas celles en amont. Or, la récupération
des sources se fait lors de l’opération <span class="courier11">git clone</span>. Celle-ci va donc aboutir à la
mise en œuvre du cache, et l’image intermédiaire
sera celle générée&nbsp;lors de la
première compilation, avec du code ancien. Il y a même
des chances pour que la commande <span class="courier11">git checkout</span> sur une
nouvelle version ne fonctionne pas, car celle-ci n’existe pas encore.</p>
          <p class="defaut">L’astuce, recommandée dans les bonnes
pratiques de Docker (<a class="url" href="https://docs.docker.com/articles/dockerfile_best-practices/" target="_blank">https://docs.docker.com/articles/dockerfile_best-practices/</a>),
consiste à regrouper les deux commandes en une seule ligne&nbsp;:</p>
          <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">FROM</span> <span class="hljs-selector-tag">ubuntu</span><span class="hljs-selector-pseudo">:trusty</span>&nbsp;
<span class="hljs-selector-tag">RUN</span> <span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">clone</span> <span class="hljs-selector-attr">[adresse du dépôt]</span> \&nbsp;
&nbsp; &nbsp;&amp;&amp; <span class="hljs-selector-tag">cd</span> <span class="hljs-selector-attr">[répertoire récupéré]</span> \&nbsp;
&nbsp; &nbsp;&amp;&amp; <span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">checkout</span> <span class="hljs-selector-tag">v1</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span>&nbsp;
<span class="hljs-selector-tag">RUN</span> <span class="hljs-selector-attr">[opération de compilation]</span></code></pre>
          <p class="defaut">Ainsi, lors de la compilation d’une autre
version, Docker verra que la commande du <span class="courier11">Dockerfile</span> a
globalement changé (rappelez-vous qu’un simple espace suffit à invalider
le code) et exécutera à nouveau l’opération
de clonage du dépôt Git, récupérant
ainsi tout le code source à jour.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">La raison pour laquelle on utilise
la commande <span class="courier11">cd</span> pour se placer dans
le répertoire créé par la commande <span class="courier11">git clone</span> est que l’introduction d’une
instruction <span class="courier11">WORKDIR</span> empêcherait
de fusionner les deux opérations <span class="courier11">RUN</span>.
Il est également possible de créer le répertoire&nbsp;en
amont et de faire pointer le <span class="courier11">git clone</span> dessus,
de façon à éviter de réaliser&nbsp;une
opération de <span class="courier11">RUN</span> sur la
commande <span class="courier11">cd</span>, ce qui est moins lisible.</p>
            </div>
          </div>
          <p class="defaut">Cette approche par modification d’un numéro
de version est plus propre que l’option vue plus haut (<span class="courier11">--no-cache</span>). En effet, elle permet
une désactivation sélective du cache uniquement
pour les commandes concernées - ainsi que les suivantes.
Mais en plus, cette méthode est plus propre du point de
vue de la maîtrise de la nécessité de
recompiler, car le gestionnaire de l’image qui intervient pour mettre à jour
la version est de fait parfaitement conscient du cycle de vie de
son image.</p>
          <p class="defaut">On retrouve le mécanisme dans certains
retours d’expérience de compilations automatiques d’images,
où les fichiers <span class="courier11">Dockerfile</span> font
parfois référence à un fichier dont le
nom est généré et change à chaque
fois que nécessaire. On peut également se servir
du fait qu’une modification du contexte invalide le cache en récupérant
un script dans le contexte en question. En poussant le raisonnement
au bout, il peut également être envisagé de
transférer tout le code source à compiler par
le contexte plutôt que d’aller le chercher à distance
par un <span class="courier11">git clone</span>. Le <span class="courier11">Dockerfile</span> est alors posé dans
le répertoire contenant tout le code source à utiliser.
Il faudra toutefois veiller dans ce cas à limiter le volume
pour des raisons de performance. En effet, tous les fichiers&nbsp;sont
recopiés dans le contexte au moment de la compilation,
ce qui peut ralentir&nbsp;fortement l’opération en
cas de volumes importants.</p>
          <p class="defaut">Pour finir, l’approche est toujours la même
dans le cas où le cache doit être invalidé alors
qu’on appelle des commandes de type <span class="courier11">apt-get</span>&nbsp;:
le plus simple est de passer la version exacte du paquetage à installer,
de telle manière que l’invalidation de cache soit naturelle,
lorsque le gestionnaire de l’image met cette dépendance à jour.
On voit souvent dans les <span class="courier11">Dockerfile</span> des
enchaînements comme ceci&nbsp;:</p>
          <pre class="programlisting"><code class="hljs sql">RUN apt-get <span class="hljs-keyword">update</span> &amp;&amp; apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> -y \&nbsp;
&nbsp; &nbsp;automake \&nbsp;
&nbsp; &nbsp;curl=<span class="hljs-number">7.35</span><span class="hljs-number">.0</span>* \&nbsp;
&nbsp; &nbsp;git \&nbsp;
&nbsp; &nbsp;mercurial</code></pre>
          <p class="defaut">La séparation ligne par ligne avec
des symboles <span class="courier11">\</span> pour passer à la
ligne et le tri alphabétique des paquetages sont des recommandations
issues de Docker. Cette écriture rend plus simple l’ajout
de paquetages, sans risquer leur duplication.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Quand <span class="courier11">apt-get
install</span> est utilisé, préciser le numéro
de version est une habitude saine. Après tout, il est logique
de connaître ce numéro lorsqu’on compile une nouvelle
image. En effet, nous avons vu plus haut qu’il était de
bonne pratique de fournir un tag à chaque compilation.
Or, comment savoir si nous avons justement besoin d’une nouvelle
compilation si nous ne savons pas quelles sont les dépendances
qui ont évolué&nbsp;? Lorsque les dépendances
sont très nombreuses, la pratique privilégie de
plus en plus de séparer les cycles de vie et de compiler à chaque
modification dans le code, en prenant systématiquement
les dernières dépendances et en vérifiant
qu’elles ne posent pas problème par une batterie de tests
d’acceptation. Mais il existe aussi des cas où la recompilation
doit se faire pour être à jour par rapport à une
dépendance qui a reçu un patch ou une évolution
essentielle. Le numéro est alors parfaitement connu et
le cycle&nbsp;de vie de la dépendance maîtrisé.</p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle11">
          <h3 class="title">c. Effets bénéfiques sur le nombre
et la taille des images</h3>
          <p class="defaut">Le regroupement de commandes montré ci-dessus
présente des bénéfices additionnels.
Prenons par exemple l’extrait de <span class="courier11">Dockerfile</span> imaginaire suivant&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript">WORKDIR /tmp&nbsp;
RUN curl http:<span class="hljs-comment">//www.gouigoux.com/big-archive.tgz -o big-archive.tgz&nbsp;</span>
RUN tar zxvf big-archive.tgz&nbsp;
RUN rm big-archive.tgz&nbsp;
WORKDIR /tmp/big-archive&nbsp;
RUN make&nbsp;
WORKDIR /&nbsp;
RUN rm -fr /tmp/big-archive</code></pre>
          <p class="defaut">La volonté de supprimer les fichiers
temporaires part d’un bon sentiment, mais comme chaque commande
est réalisée dans une étape séparée
et que chacune résulte en une image correspondant à son état,
l’image correspondant au pas n°2 dans notre exemple va nécessairement
contenir les fichiers extraits de l’archive. Et la suppression au
pas n°3 ne réduira en rien la taille de cette image&nbsp;;
elle créera simplement une autre image (il est vrai très
petite) qui stockera l’information que les fichiers sont supprimés
pour la suite.</p>
          <p class="defaut">La taille totale des images suivra la composition
suivante&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP75.png" title="images/04EP75.png" src="IMAGES/04EP75.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Pour cette raison, il est plus propre d’écrire
le <span class="courier11">Dockerfile</span> comme suit&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript">WORKDIR /tmp&nbsp;
RUN curl http:<span class="hljs-comment">//www.gouigoux.com/big-archive.tgz -o big-archive.tgz \&nbsp;</span>
&nbsp; &nbsp;&amp;&amp; tar xzvf big-archive.tgz \&nbsp;
&nbsp; &nbsp;&amp;&amp; rm big-archive.tgz \&nbsp;
&nbsp; &nbsp;&amp;&amp; cd /tmp/big-archive \&nbsp;
&nbsp; &nbsp;&amp;&amp; make \&nbsp;
&nbsp; &nbsp;&amp;&amp; cd .. \&nbsp;
&nbsp; &nbsp;&amp;&amp; rm -fr /tmp/big-archive</code></pre>
          <p class="defaut">À la fin de l’exécution
de cette commande, une seule image aura été générée au
lieu de sept, et surtout elle ne contiendra que les fichiers générés
par la compilation (<span class="courier11">make</span>), et aucun
des fichiers temporaires.</p>
          <p class="defaut">La composition de commande ne produira qu’une
image, ce qu’on pourrait représenter comme ceci&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP76.png" title="images/04EP76.png" src="IMAGES/04EP76.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Le même effet d’empilement des images
apparaît lorsque la commande <span class="courier11">ADD</span> est
utilisée pour aller récupérer le contenu
d’une URL, qu’il faut ensuite supprimer. Il est donc recommandé de
remplacer cette approche par une opération <span class="courier11">RUN</span> commençant par effectuer&nbsp;un
téléchargement par <span class="courier11">curl</span> ou <span class="courier11">wget</span> comme nous venons de faire.</p>
          <p class="defaut">Il est d’ailleurs possible d’aller encore
plus loin en se passant du fichier d’archive, qui n’est que temporaire.
Pour cela, nous pouvons utiliser les pipes Linux pour envoyer le
contenu dans l’utilitaire <span class="courier11">tar</span>. L’option <span class="courier11">-o</span> est alors inutile, ainsi que le
nom du fichier dans la commande <span class="courier11">tar</span> et
la commande de suppression du fichier, qui n’a existé à aucun&nbsp;moment&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript">WORKDIR /tmp&nbsp;
RUN curl http:<span class="hljs-comment">//www.gouigoux.com/big-archive.tgz | tar xzvf \&nbsp;</span>
&nbsp; &nbsp;&amp;&amp; cd /tmp/big-archive \&nbsp;
&nbsp; &nbsp;&amp;&amp; make \&nbsp;
&nbsp; &nbsp;&amp;&amp; cd .. \&nbsp;
&nbsp; &nbsp;&amp;&amp; rm -fr /tmp/big-archive</code></pre>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">De manière générale,
il est recommandé lors des premières compilations
de surveiller la taille des images. Avec la pratique, les gaspillages
de ressources sautent aux yeux. Si malgré tout une erreur
se glisse dans votre processus, il reste possible d’écraser
une pile d’images en une seule, en utilisant l’astuce dispensée
sur : <a class="url" href="https://docs.docker.com/engine/reference/commandline/build/#squash-an-images-layers---squash-experimental" target="_blank">https://docs.docker.com/engine/reference/commandline/build/#squash-an-images-layers---squash-experimental</a></p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle12">
          <h3 class="title">d. Ordonnancement des commandes dans le Dockerfile</h3>
          <p class="defaut">Pour finir, quelques bonnes pratiques d’ordonnancement
peuvent également aider à garder des images compactes.</p>
          <p class="defaut">Tout d’abord, afin de bénéficier
le plus longtemps possible du cache, il est intéressant
de remonter le plus haut possible dans le fichier <span class="courier11">Dockerfile</span> les commandes qui ne changent
pas, comme par exemple <span class="courier11">ENTRYPOINT</span> ou <span class="courier11">CMD</span>. Cela peut paraître contre-intuitif,
car comme elles décrivent le processus qui va être
lancé après toutes ses phases de préparation,
la tendance est naturellement de les mettre en fin de fichier. Mais
Docker ne rend pas ceci obligatoire donc autant en profiter.</p>
          <p class="defaut">Une autre amélioration sur des images
nécessitant la compilation de code source est de mettre
en avant les opérations de restauration des dépendances, puis
seulement de recopier le code source et de le compiler. Ce mode
de fonctionnement est particulièrement utile avec les frameworks
récupérant les dépendances sur des dépôts
sur internet (Node.js, .NET Core avec des dépendances NuGet,
etc.), car une rupture de cache dans ce cas peut amener à de
lourds téléchargements. De plus, si un cache de
modules n’a pas été mis en œuvre
dans l’entreprise, ces téléchargements
seront multipliés par le nombre de développeurs,
ce qui peut poser des problèmes de performance mais aussi&nbsp;de
consommation de bande passante.</p>
          <p class="defaut">De manière générale,
la vitesse de compilation d’une image vient d’un
assemblage de nombreuses astuces et bonnes pratiques sans cesse
en mouvement. Un apprentissage est donc nécessaire en permanence,
et une veille permet également de se renseigner sur les
nouvelles approches de réduction massive des images par
compilation native et production d’images réduites
au seul exécutable, sans les outils qui ont permis de le
créer. La page <a class="url" href="http://container-solutions.com/lean-go-containers-multi-stage-dockerfiles/" target="_blank">http://container-solutions.com/lean-go-containers-multi-stage-dockerfiles/</a> décrit
ce mécanisme pour le langage Go, en utilisant les compilations
Docker multi-stage (voir plus loin), pour un résultat d’une
image fonctionnelle pesant seulement 1,55&nbsp;Mo. La récente
mise à disposition d’un compilateur natif et d’un
linker pour Core .NET rend également envisageable ce type
de mise en œuvre ultralégère pour cette
autre plateforme de développement moderne.</p>
        </div>
      </div>
      <div class="sect2" id="refTitle13">
        <h2 class="title">4. Ajout d’une image de cache intermédiaire</h2>
        <p class="defaut">Il existe un autre niveau auquel un cache
peut être ajouté et sur lequel le concepteur du <span class="courier11">Dockerfile</span> a la main&nbsp;: il
s’agit de la décomposition d’une image en plusieurs images
chainées. Nous avons vu plus haut que la compilation utilisait
la structure empilée&nbsp;des images pour mettre en
cache le maximum d’opérations et avons même montré des
bonnes pratiques d’écriture et d’ordonnancement des <span class="courier11">Dockerfile</span> pour favoriser l’utilisation
au maximum du cache. Nous allons maintenant illustrer comment ce <span class="courier11">Dockerfile</span> peut être découpé en
deux fichiers séparés à notre avantage.</p>
        <p class="defaut">Une des opérations les plus longues
lors de la compilation d’une image est l’installation des paquetages
Linux nécessaires. Prenons par exemple le <span class="courier11">Dockerfile</span> ci-dessous,&nbsp;que
nous avons utilisé un peu plus haut&nbsp;:</p>
        <pre class="programlisting"><code class="hljs sql">FROM ubuntu:focal&nbsp;
&nbsp;
RUN apt-get <span class="hljs-keyword">update</span> \&nbsp;
&nbsp;&amp;&amp; apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> -y \&nbsp;
&nbsp; &nbsp;python3 \&nbsp;
&nbsp; &nbsp;python3-pip \&nbsp;
&nbsp;&amp;&amp; pip3 <span class="hljs-keyword">install</span> Flask&nbsp;
&nbsp;
COPY src/ .&nbsp;
&nbsp;
EXPOSE <span class="hljs-number">5000</span>&nbsp;
ENTRYPOINT [<span class="hljs-string">"python3"</span>]&nbsp;
CMD [<span class="hljs-string">"webtest.py"</span>]</code></pre>
        <p class="defaut">La commande <span class="courier11">RUN</span> installe
Python, ce qui prend un certain temps (quelques minutes avec un
accès ADSL correct). C’est la raison pour laquelle cette
commande a été placée le plus haut possible
dans le fichier. La commande <span class="courier11">COPY</span>, qui
s’occupe de récupérer le code source, est placée
en dessous. En effet, le code source change très régulièrement,
et c’est typiquement le fait qu’il existe une nouvelle version qui
justifie de recompiler une image. Ainsi, l’installation de Python
est réalisée une bonne fois pour toutes, et les
nouvelles versions du code source ne nécessitent pas de
relancer cette opération coûteuse.</p>
        <p class="defaut">Il existe pourtant des cas dans lesquels il
est plus complexe de garder ce mécanisme propre. Cela peut
venir du <span class="courier11">Dockerfile</span> lui-même,
mais aussi de la machine servant pour la compilation. Par exemple,
si ces machines sont multiples pour accélérer
le processus de build de nombreuses images, la génération
de la couche intermédiaire se fera plusieurs fois.</p>
        <p class="defaut">Une bonne pratique est alors d’utiliser l’astuce
d’image de base dédiée montrée un peu
plus haut et d’utiliser le réseau pour centraliser celle-ci,
que ce soit par un registre local ou par un miroir comme montré un
peu plus haut. Le <span class="courier11">Dockerfile</span> de
l’image de base sera alors&nbsp;:</p>
        <pre class="programlisting"><code class="hljs sql">FROM ubuntu:focal&nbsp;
&nbsp;&nbsp;
RUN apt-get <span class="hljs-keyword">update</span> \&nbsp;
&nbsp;&amp;&amp; apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> -y \&nbsp;
&nbsp; &nbsp;python3 \&nbsp;
&nbsp; &nbsp;python3-pip \&nbsp;
&nbsp;&amp;&amp; pip3 <span class="hljs-keyword">install</span> Flask&nbsp;
&nbsp;
ENTRYPOINT [<span class="hljs-string">"python3"</span>]</code></pre>
        <p class="defaut">En supposant que ce fichier est compilé en
une image qu’on nommerait par exemple <span class="courier11">jpgouigoux/pythonbase</span>,
alors celui de l’image originale deviendrait&nbsp;:</p>
        <pre class="programlisting"><code class="hljs vbnet"><span class="hljs-keyword">FROM</span> jpgouigoux/pythonbase&nbsp;
&nbsp;
COPY src/ .&nbsp;
&nbsp;
EXPOSE <span class="hljs-number">5000</span>&nbsp;
CMD [<span class="hljs-string">"webtest.py"</span>]</code></pre>
        <p class="defaut">Pour ce qui est de partager l’image de base
entre les différentes machines intéressées,
nous reviendrons plus loin dans le chapitre sur ce point en illustrant la
création d’un registre.</p>
      </div>
      <div class="sect2" id="refTitle14">
        <h2 class="title">5. Mise en œuvre d’un cache de paquetages</h2>
        <p class="defaut">Dans les cas où les astuces d’amélioration
de la performance par cache ci-dessus ne suffisent pas, par exemple
dans des environnements de développement où les
prérequis changent souvent, une autre solution est de positionner
un niveau de cache directement au niveau du téléchargement
des paquetages Linux. Le logiciel Aptitude utilisé sur
les distributions basées sur Debian, comme Ubuntu, se prête à ce
mode de fonctionnement, et comme d’habitude, le plus simple est
de mettre en place un conteneur Docker pour implémenter ce
mode de fonctionnement.</p>
        <p class="defaut">Le <span class="courier11">Dockerfile</span> à utiliser
est le suivant&nbsp;:</p>
        <pre class="programlisting"><code class="hljs vbnet"><span class="hljs-keyword">FROM</span> ubuntu:trusty&nbsp;
RUN apt-<span class="hljs-keyword">get</span> update &amp;&amp; apt-<span class="hljs-keyword">get</span> install -y apt-cacher-ng&nbsp;
EXPOSE <span class="hljs-number">3142</span>&nbsp;
ENTRYPOINT [<span class="hljs-string">"/usr/sbin/apt-cacher-ng"</span>]&nbsp;
CMD [<span class="hljs-string">"-c"</span>, <span class="hljs-string">"/etc/apt-cacher-ng"</span>, <span class="hljs-string">"ForeGround=1"</span>]</code></pre>
        <p class="defaut">Les lignes correspondent aux différentes
opérations suivantes&nbsp;:</p>
        <div class="divliste1">
          <ul class="liste1">
            <li class="liste1">
              <p class="liste1"><span class="courier11">FROM</span> pointe
sur l’image de base, comme d’habitude.</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">RUN</span> installe
l’application <span class="courier11">apt-cacher-ng</span>, qui
est l’application choisie pour réaliser le cache de paquetages
Aptitude (option <span class="courier11">-y</span> comme d’habitude pour
que le comportement ne soit pas interactif et que la demande de confirmation
de téléchargement soit automatiquement traitée
comme acceptée).</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">EXPOSE</span> publie
le port 3142 comme celui à utiliser pour accéder
au cache.</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">ENTRYPOINT</span> démarre
le programme <span class="courier11">apt-cacher-ng</span> lorsque
le conteneur sera lancé.</p>
            </li>
            <li class="liste1">
              <p class="liste1"><span class="courier11">CMD</span> permet
de spécifier les options par défaut, à savoir&nbsp;:</p>
            </li>
          </ul>
        </div>
        <div class="divliste2">
          <ul class="liste2">
            <li class="liste2">
              <p class="liste2">l’utilisation du répertoire
de configuration <span class="courier11">/etc/apt-cacher-ng</span> (il s’agit
de l’emplacement par défaut, mais il est utile de le préciser),</p>
            </li>
            <li class="liste2">
              <p class="liste2">la mise en avant-plan du processus,
sinon l’application rendra la main et le conteneur s’arrêtera
immédiatement après l’avoir lancé, rendant
l’ensemble inutilisable.</p>
            </li>
          </ul>
        </div>
        <p class="defaut">Le conteneur peut alors être démarré,
juste après la compilation de l’image&nbsp;:</p>
        <pre class="programlisting"><code class="hljs sql">docker build -t cacher .&nbsp;
docker run -d -p 3142:3142 <span class="hljs-comment">--name apt-cache cacher</span></code></pre>
        <p class="defaut">L’étape suivante consiste à faire
en sorte que lors des compilations d’images Docker qui appellent
souvent des paquetages, ce soit ce cache qui soit appelé au
lieu des dépôts&nbsp;distants. Pour cela,
il faut rajouter dans la définition de ces images une entrée
dans le répertoire de configuration.</p>
        <p class="defaut">Imaginons un <span class="courier11">Dockerfile</span> qui
nous sert de base pour du développement Python et sur lequel
nous allons souvent ajouter des paquetages à installer.
Nous pourrions créer une couche pour chaque nouveau paquetage,
mais nous pouvons aussi réinstaller tous les paquetages
au build si nous incluons la seconde ligne du <span class="courier11">Dockerfile</span> ci-dessous&nbsp;:</p>
        <pre class="programlisting"><code class="hljs javascript">FROM ubuntu:trusty&nbsp;
RUN &nbsp;echo ’Acquire::http { <span class="hljs-built_in">Proxy</span> <span class="hljs-string">"http://192.168.0.7:3142"</span>; };’&nbsp;
&gt;&gt; <span class="hljs-regexp">/etc/</span>apt/apt.conf.d/<span class="hljs-number">01</span>proxy&nbsp;
RUN apt-<span class="hljs-keyword">get</span> update &amp;&amp; apt-<span class="hljs-keyword">get</span> install -y build-essential python&nbsp;
python-dev&nbsp;
ENTRYPOINT ["python"]</code></pre>
        <p class="defaut">Le répertoire de configuration d’Aptitude
se retrouve alors enrichi avec une adresse de proxy qui pointe sur
le cache que nous venons de mettre en œuvre dans un conteneur
(ne pas oublier de modifier l’adresse IP pour pointer sur la bonne
machine).</p>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">Là encore, si vous souhaitez
ne pas avoir à entrer systématiquement cette opération
dans chacun de vos <span class="courier11">Dockerfile</span>, avec
le risque associé d’oubli, l’astuce de l’image de base
personnalisée peut s’appliquer (voir plus haut).</p>
          </div>
        </div>
        <p class="defaut">Lors de la première compilation,
le processus prend un certain temps, que nous pouvons constater
en ajoutant la commande <span class="courier11">time</span> devant
la commande docker <span class="courier11">build</span>&nbsp;:</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP80.png" title="images/04EP80.png" src="IMAGES/04EP80.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
        </div>
        <p class="defaut">Pour être bien sûrs de ne
pas avoir l’effet de cache de Docker, mais bien de constater uniquement
celui du cache sur les paquetages Aptitude, nous relançons
la commande après avoir supprimé l’image créée&nbsp;:</p>
        <pre class="programlisting"><code class="hljs perl">sudo docker rmi devpython&nbsp;
<span class="hljs-keyword">time</span> sudo docker build -t devpython .</code></pre>
        <p class="defaut">Les résultats montrent clairement
le gain de temps, pour ce <span class="courier11">Dockerfile</span> avec
simplement trois paquetages&nbsp;:</p>
        <div class="image">
          <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP81.png" title="images/04EP81.png" src="IMAGES/04EP81.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
        </div>
        <p class="defaut">Avec un accès ADSL à peu
près standard, l’amélioration est de 100 secondes sur
135&nbsp;: la compilation nécessite donc seulement
le quart du temps qui aurait été requis si le
cache de paquetages n’avait pas été mis en œuvre&nbsp;!
Une minute et demie gagnée sur ce simple exemple peut paraître
peu, mais multipliée par quelques dizaines de compilations
dans la journée et par quelques dizaines de développeurs
pour une entreprise d’édition standard, les gains de temps
sont substantiels à la fin de l’année, surtout
qu’ils s’accompagnent d’économie de ressources précieuses
(bande passante, principalement). Enfin, au-delà de ces gains
"techniques", le plus important est peut-être le maintien
facilité de la concentration du développeur sur
sa tâche intellectuelle en cours, son attention retombant
moins à cause de la phase de compilation.</p>
        <div class="note">
          <div class="remarkimg"><span class="icon-note"></span></div>
          <div class="divinline">
            <p class="remarque">Nous avons montré un conteneur
de cache de paquetages qui, une fois arrêté, va
perdre son contenu stocké, mais il est possible (et même
recommandé) d’utiliser la gestion des volumes pour que
cette base de données de cache soit persistée
même en cas de redémarrage du conteneur. Une commande <span class="courier11">docker diff [nom du conteneur de
cache des paquetages]</span> vous montrera où les
fichiers sont stockés (à savoir <span class="courier11">/var/cache/apt-cacher-ng/</span>),
information que vous donnerait également la lecture du
fichier de configuration du cache <span class="courier11">/etc/apt-cacher-ng/acng.conf</span>.</p>
          </div>
        </div>
      </div>
      <div class="sect2" id="refTitle15">
        <h2 class="title">6. Conséquences sur le choix des images de base</h2>
        <div class="sect3" id="refTitle16">
          <h3 class="title">a. La bonne image de base</h3>
          <p class="defaut">Les conséquences du mécanisme
de cache, et de manière générale du mode
de fonctionnement des images qui s’empilent les unes sur les autres,
sont de plusieurs ordres.</p>
          <p class="defaut">Tout d’abord, il est essentiel de ne pas démultiplier
les images de base. Sauf si un besoin particulier est levé,
il est recommandé de choisir une distribution et de s’y
tenir le plus possible. Si toutes les images sont construites à partir
d’une image <span class="courier11">debian:buster-slim</span>,
par exemple, les quelque 80&nbsp;Mo correspondants seront téléchargés
une bonne fois pour toutes, et seule la partie supérieure
des images fluctuera. Sur une <span class="courier11">debian:buster</span>,
nous parlons de 115&nbsp;Mo environ, mais même si l’image
est plus imposante, l’important reste surtout de ne pas démultiplier
les distributions et les versions. Si certaines de vos images sont
basées sur une <span class="courier11">ubuntu:focal</span>,
d’autres sur une <span class="courier11">ubuntu:xenial</span>,
d’autres encore sur <span class="courier11">debian:buster</span> et
les dernières sur une <span class="courier11">centos:latest</span>,
vous démultiplierez la charge sur le disque (ce qui peut être gênant)
mais aussi sur la bande passante (ce qui est généralement
plus impactant, car en lien direct avec les performances).</p>
          <p class="defaut">Le choix de la version de l’image est également
important. Utiliser le défaut <span class="courier11">latest</span> (la
dernière) aboutit au bout de quelque temps à la
présence de plusieurs versions effectives&nbsp;dans
votre cache d’images locales, si le tag <span class="courier11">latest</span> bouge
beaucoup. Là encore,&nbsp;il est plus propre de valider
une version donnée et de vous y tenir. Sauf besoin particulier,
lorsque vous utilisez une image <span class="courier11">ubuntu</span>,
il est logique d’utiliser la dernière LTS, et l’équipe
maintenant l’image officielle fait justement l’effort de ne faire
bouger l’étiquette <span class="courier11">latest</span> qu’à l’intérieur
des versions mineures de la LTS, de façon à suivre
les patches, mais sans imposer un changement plus conséquent
d’image aux utilisateurs.</p>
          <p class="defaut">Enfin, nul besoin d’utiliser des images aussi
importantes dans tous les cas. Les images <span class="courier11">ubuntu</span> et <span class="courier11">debian</span> sont très connues,
car elles proposent des distributions quasi complètes,
même si un gros effort de réduction de taille
a été entrepris par rapport aux versions proposées à l’installation
comme OS principal d’une machine physique, et qui occupent allégrement
un DVD de 4,7&nbsp;Go. Mais dans les 20&nbsp;% de
cas les plus simples, qui représentent 80&nbsp;% des
usages, une image réduite comme <span class="courier11">alpine</span> ou <span class="courier11">busybox</span> peut faire l’affaire, et elle
ne pèse que quelques mégaoctets.</p>
          <p class="defaut">Les éditeurs des distributions font
eux-mêmes attention à la taille de leurs images,
et la taille de l’image de base Ubuntu a bien baissé en
quelques années. Même si 73&nbsp;Mo paraissent
encore démesurés pour des usages de microservices, il
convient de se rappeler que lors de la première version
de ce livre (2015), la même image pesait 190&nbsp;Mo,
puis qu’elle est passée à 125&nbsp;Mo lors
de la seconde édition. La réduction est aussi
visible&nbsp;côté Debian, selon les mêmes
ratios à peu près.</p>
          <p class="defaut">Le même effort de concision a été porté sur
les images de base pour les conteneurs Windows, qui partaient d’encore
plus loin car Docker a été pensé comme
une technologie Linux et le portage dans Windows n’était
pas évident. Comme le mode de fonctionnement même
du système est différent, il est par exemple plus
complexe de se baser sur des primitives du système d’exploitation
sous-jacent, et les images de base embarquaient donc au tout début
un système quasi complet. Ainsi, une image Windows&nbsp;Server
Base complète pesait plusieurs gigaoctets.</p>
          <p class="defaut">Aujourd’hui, les images ont subi une cure
d’amaigrissement plus ou moins forte selon les versions. Un parcours
de <a class="url" href="https://hub.docker.com/_/microsoft-windows-base-os-images" target="_blank">https://hub.docker.com/_/microsoft-windows-base-os-images</a> permettra
de pointer sur les différentes versions disponibles, dont
les tailles au moment de l’écriture sont reportées
ci-dessous&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1">mcr.microsoft.com/windows/servercore:ltsc2019&nbsp;:
5,06 Go</p>
              </li>
              <li class="liste1">
                <p class="liste1">mcr.microsoft.com/windows/nanoserver:1809&nbsp;:
251 Mo</p>
              </li>
              <li class="liste1">
                <p class="liste1">mcr.microsoft.com/windows/iotcore:1809&nbsp;:
790 Mo</p>
              </li>
              <li class="liste1">
                <p class="liste1">mcr.microsoft.com/windows/servercore:20H2&nbsp;:
4,7 Go</p>
              </li>
              <li class="liste1">
                <p class="liste1">mcr.microsoft.com/windows/nanoserver:20H2&nbsp;:
263 Mo</p>
              </li>
            </ul>
          </div>
        </div>
        <div class="sect3" id="refTitle17">
          <h3 class="title">b. Votre propre image de base</h3>
          <p class="defaut">Un autre moyen efficace de gagner de la place
est de mettre en place une couche d’image pour toutes les fonctionnalités
que vous utilisez souvent. Par exemple, une équipe de développement
va être habituée à trouver certains outils
sur les machines d’exécution de leurs applications. Une équipe
orientée web aura besoin de Nginx, NodeJS,&nbsp;AngularJS,
etc. Si des images sont construites souvent pour mettre en test
des applicatifs développés par cette équipe,
une bonne pratique est de construire une image commune "développement
web", qui servira de base pour toutes ces machines de test qui n’ont souvent
qu’une durée de vie très limitée (le
temps des tests, une autre version arrivant quelques heures plus
tard à peine si l’équipe travaille en flux tendu).</p>
          <p class="defaut">Les gains en termes de performance sont essentiels
pour travailler en intégration continue. Les quelques dizaines
de secondes pour télécharger, installer et paramétrer
les dépendances coûtent cher à la fin
de l’année lorsque des dizaines d’images de test ont été générées
chaque jour. Le confort est également amélioré pour
les équipes.</p>
          <p class="defaut">Imaginons par exemple une image pour mettre
en place un serveur web écrit en Python&nbsp;et dont
une équipe de développement se servirait pour
lancer plusieurs fois par jour des tests sur chacun des postes de
développement. Ces tests seraient typiquement exécutés
sur un conteneur démarré uniquement pour valider
que les modifications du code de chaque développeur ne
posent pas de problème.</p>
          <p class="defaut">Un tel <span class="courier11">Dockerfile</span> serait
comme suit&nbsp;:</p>
          <pre class="programlisting"><code class="hljs sql">FROM ubuntu:focal&nbsp;
&nbsp;
RUN apt-get <span class="hljs-keyword">update</span> \&nbsp;
&nbsp;&amp;&amp; apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> -y \&nbsp;
&nbsp; &nbsp;python3 \&nbsp;
&nbsp; &nbsp;python3-pip \&nbsp;
&nbsp;&amp;&amp; pip3 <span class="hljs-keyword">install</span> Flask&nbsp;
&nbsp;
COPY webtest.py webtest.py&nbsp;
&nbsp;
EXPOSE <span class="hljs-number">5000</span>&nbsp;
ENTRYPOINT [<span class="hljs-string">"python3"</span>]&nbsp;
CMD [<span class="hljs-string">"webtest.py"</span>]</code></pre>
          <p class="defaut">Nous profitons de la présentation
de ce <span class="courier11">Dockerfile</span> pour rappeler les bonnes
pratiques&nbsp;:</p>
          <div class="divliste1">
            <ul class="liste1">
              <li class="liste1">
                <p class="liste1">Utilisation d’une
image de base avec une version explicite&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">Regroupement des commandes d’installation
en une seule opération <span class="courier11">run</span>&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">Disposition sur des lignes pour
faciliter leur lecture&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">Ajout d’un espace avant le symbole <span class="courier11">\</span> de renvoi à la
ligne, également pour éclaircir le texte à la
lecture&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">Respect de l’ordre alphabétique
pour rendre visibles les éventuels doublons au cours des
futurs ajouts&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">Utilisation préférentielle
de l’opération <span class="courier11">copy</span> plutôt
que <span class="courier11">add</span>&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">Positionnement de la commande de
recopie du fichier de source après la commande gérant
les installations des outils, beaucoup plus lourdes, de façon à ne
surtout pas invalider ce niveau de cache quand une modification du
code source est réalisée (c’est un point essentiel)&nbsp;;</p>
              </li>
              <li class="liste1">
                <p class="liste1">Séparation <span class="courier11">ENTRYPOINT</span> et <span class="courier11">CMD</span>.</p>
              </li>
            </ul>
          </div>
          <p class="defaut">Un coup d’œil à la structure
de l’image en utilisant la commande <span class="courier11">history</span> nous
montre que les outils installés ont pris plus de 320&nbsp;Mo&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP77.png" title="images/04EP77.png" src="IMAGES/04EP77.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Clairement, l’utilisation du cache est impérative,
et l’idée de partager une image de base contenant ces outils
entre toutes les personnes d’une équipe de développement
peut éviter des pertes de temps sur les reconstructions.
Ainsi, tous les développeurs peuvent utiliser une image
de base à jour, sans avoir à passer par les étapes
de compilation. Le gain n’est dans ce cas pas exceptionnellement élevé,
car chaque machine de développement a son propre cache d’images
de toute façon, mais nous verrons dans un prochain chapitre
un second exemple avec un cas particulier de compilation d’application&nbsp;qui
rend le montage avec une image de base "développement"
particulièrement utile.</p>
          <p class="defaut">Sans trop anticiper sur cet exemple, il s’agit
d’un environnement .NET où les dépendances sont
récupérées par NuGet et donc téléchargées
dynamiquement en fonction du code source. Comme le chargement du
code source dans l’image se fait avant la récupération&nbsp;des
dépendances par NuGet, cette dernière étape
de la construction repart&nbsp;toujours de zéro à chaque
modification de code, alors que dans une très grande majorité des
cas il s’agit des mêmes librairies. Le fait de préparer
une image de base avec du code "standard" (entraînant ainsi
le téléchargement de toutes les librairies les
plus communes) permet de gagner beaucoup de temps sur toutes les
autres compilations d’images après coup.</p>
          <p class="defaut">Nous reviendrons plus en détail sur
cette bonne pratique lors de la mise en place de l’application exemple
qui va nous servir pour démontrer la gestion d’un déploiement
Docker plus industriel, dans un chapitre suivant.</p>
        </div>
        <div class="sect3" id="refTitle18">
          <h3 class="title">c. Adapter l’image de base avec les compilations multi-stage<var style="display:none"> Multi-stage</var></h3>
          <p class="defaut">Comme nous l’avons vu plus haut, il est courant
que la génération d’images Docker nécessite
des opérations de récupération de code
source, de compilation, d’exécution de scripts, avec toutes
les dépendances que cela rend nécessaires, mais
aussi toutes les créations de fichiers temporaires et téléchargements
uniquement utiles pour la courte période de compilation
elle-même, et qui ne servent ensuite pas lors de l’exécution
des conteneurs eux-mêmes.</p>
          <p class="defaut">Des astuces sont possibles pour éviter
de surcharger les images intermédiaires, mais les outils
dits "build time" restent tout de même pour une bonne partie à l’intérieur
de l’image résultante, car ils doivent être installés
avant les opérations de construction des exécutables.
L’image est ainsi encombrée de fichiers qui ne serviront
jamais lors de l’exécution de l’image (le "run time").</p>
          <p class="defaut">Pour éviter cette perte de place
et permettre d’obtenir des images encore plus légères
et donc faciles à déployer, Docker propose depuis
quelques versions la possibilité de compiler des images
avec une image de base qui varie au fur et à mesure de
l’enchaînement d’instructions, ce qui constitue des "stages"
de compilation. Le plus simple pour expliquer ce concept est de
le montrer sur un exemple. Nous utiliserons ci-dessous celui fourni
par Microsoft pour la création d’une image Docker d’une
application ASP.NET Core (<a class="url" href="https://docs.microsoft.com/fr-fr/aspnet/core/host-and-deploy/docker/building-net-docker-images?view=aspnetcore-3.1" target="_blank">https://docs.microsoft.com/fr-fr/aspnet/core/host-and-deploy/docker/building-net-docker-images?view=aspnetcore-3.1</a>).
Le fichier <span class="courier11">Dockerfile</span> recommandé&nbsp;est
reproduit ci-dessous&nbsp;:</p>
          <pre class="programlisting"><code class="hljs vbnet"><b><span class="hljs-keyword">FROM</span> mcr.microsoft.com/dotnet/core/sdk:<span class="hljs-number">3.1</span> <span class="hljs-keyword">AS</span> build</b>&nbsp;
WORKDIR /source&nbsp;
&nbsp;
<span class="hljs-meta"># copy csproj and restore as distinct layers&nbsp;</span>
COPY *.sln .&nbsp;
COPY aspnetapp/*.csproj ./aspnetapp/&nbsp;
RUN dotnet restore&nbsp;
&nbsp;
<span class="hljs-meta"># copy everything <span class="hljs-meta-keyword">else</span> and build app&nbsp;</span>
COPY aspnetapp/. ./aspnetapp/&nbsp;
WORKDIR /source/aspnetapp&nbsp;
RUN dotnet publish -c release -o /app --no-restore&nbsp;
&nbsp;
<span class="hljs-meta"># final stage/image</span><b><span class="hljs-meta">&nbsp;</span>
<span class="hljs-keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="hljs-number">3.1</span> <span class="hljs-keyword">AS</span> runtime</b>&nbsp;
WORKDIR /app<b>&nbsp;
COPY --<span class="hljs-keyword">from</span>=build /app ./</b>&nbsp;
ENTRYPOINT [<span class="hljs-string">"dotnet"</span>, <span class="hljs-string">"aspnetapp.dll"</span>]</code></pre>
          <p class="defaut">Ce fichier présente ce qui auparavant
serait passé pour une incongruité, à savoir
deux instructions <span class="courier11">FROM</span> différentes,
avec un mot-clé <span class="courier11">AS</span> qui
permet de leur donner un alias. Le lecteur notera que les alias
sont justement choisis pour refléter les deux étapes
citées plus haut, à savoir le build time, puis
le run time.</p>
          <p class="defaut">Comme on peut le voir, les instructions après
le premier <span class="courier11">FROM</span> sont celles liées à la
préparation du contenu de l’application ASP.NET, à savoir
la récupération des dépendances (commande <span class="courier11">dotnet restore</span>) et la compilation
des librairies (commande <span class="courier11">dotnet publish</span>).
Pour réaliser ces instructions, il est nécessaire
d’avoir tous les outils&nbsp;de compilation de .NET Core, qui
sont contenus dans le Software Development Kit, ce qui explique
que l’image de base soit <span class="courier11">dotnet/core/sdk</span> (issue
du registre <span class="courier11">mcr.microsoft.com</span>, Microsoft ayant
décidé que ses images de base seraient sur son
propre registre et non sur Docker Hub). À la fin de cette
première étape, les fichiers&nbsp;générés
sont dans le répertoire <span class="courier11">app</span>.</p>
          <p class="defaut">Ensuite, l’image de base est changée
par un second <span class="courier11">FROM</span>, qui utilise
cette fois l’image <span class="courier11">dotnet/core/aspnet</span>,
qui correspond à la runtime d’ASPNET Core, et qui est bien
sûr beaucoup plus légère que l’image
avec le SDK complet. L’instruction qui nous intéresse&nbsp;tout
particulièrement dans cet exemple est le <span class="courier11">COPY</span> qui suit, avec une option <span class="courier11">--from</span> qui permet de dire depuis quel
stage de compilation cette instruction s’applique.&nbsp;En l’occurrence,
nous recopions le répertoire <span class="courier11">app</span>,
mais bien celui qui vient de l’étape de compilation précédente, qui
avait été associée à un alias <span class="courier11">build</span> par le mot-clé <span class="courier11">AS</span> du premier <span class="courier11">FROM</span>. Ainsi,
le résultat de la publication de l’application ASP.NET,
soit les livrables exécutables, est bien recopié dans
l’image se basant sur une nouvelle image de base, mais seulement
ces fichiers et aucun des outils précédemment
utilisés. L’image finale contient donc tout ce qui est
nécessaire pour exécuter l’application (et bien
l’exécuter, pas la construire).</p>
          <p class="defaut">En compilant ce fichier <span class="courier11">Dockerfile</span>,
le lecteur pourra constater que l’image résultante pèse
environ 212 Mo.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Pour récupérer une
application exemple, le plus simple est de cloner le dépôt <a class="url" href="https://github.com/dotnet/dotnet-docker" target="_blank">https://github.com/dotnet/dotnet-docker</a></p>
            </div>
          </div>
          <p class="defaut">Si nous avions utilisé un seul <span class="courier11">FROM</span> et réalisé une
compilation d’image Docker "traditionnelle", en laissant l’image
de base avec le SDK comme image de base pour le lancement des conteneurs,
le poids de l’image complète aurait été trois fois
plus gros environ, avec une taille de 718&nbsp;Mo.</p>
          <p class="defaut">Cette manipulation, qui consiste à supprimer
les trois avant-dernières instructions, est d’ailleurs
intéressante à un autre titre que la constatation
de la taille d’une image sans utiliser cette bonne pratique, car
elle montre bien l’intérêt d’une structure propre
de <span class="courier11">Dockerfile</span>. La compilation du
fichier <span class="courier11">Dockerfile</span> repris ci-dessous
est quasi immédiate, car toutes les instructions sauf la dernière
bénéficient du cache&nbsp;:</p>
          <pre class="programlisting"><code class="hljs vbnet"><span class="hljs-keyword">FROM</span> mcr.microsoft.com/dotnet/core/sdk:<span class="hljs-number">3.1</span> <span class="hljs-keyword">AS</span> build&nbsp;
WORKDIR /source&nbsp;
&nbsp;
<span class="hljs-meta"># copy csproj and restore as distinct layers&nbsp;</span>
COPY *.sln .&nbsp;
COPY aspnetapp/*.csproj ./aspnetapp/&nbsp;
RUN dotnet restore&nbsp;
&nbsp;
<span class="hljs-meta"># copy everything <span class="hljs-meta-keyword">else</span> and build app&nbsp;</span>
COPY aspnetapp/. ./aspnetapp/&nbsp;
WORKDIR /source/aspnetapp&nbsp;
RUN dotnet publish -c release -o /app --no-restore&nbsp;
&nbsp;
<span class="hljs-meta"># final stage/image&nbsp;</span>
ENTRYPOINT [<span class="hljs-string">"dotnet"</span>, <span class="hljs-string">"aspnetapp.dll"</span>]</code></pre>
          <p class="defaut">Seule l’instruction <span class="courier11">ENTRYPOINT</span> doit être
recompilée car le fichier a été modifié au-dessus,
et comme il s’agit uniquement d’un paramétrage de l’image,
l’effet est immédiat.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Tous les éditeurs ne font
pas encore l’effort de fournir une image pour le build et une image
pour la runtime. Microsoft a été le premier à se
saisir en masse de cette fonctionnalité, qui tombe à point
nommé pour réduire la taille - il est vrai
importante - des images Docker incorporant des applications
.NET Core. Le mouvement continue heureusement&nbsp;pour baisser
la taille des images en jouant sur .NET lui-même et les
couches inférieures. Pour beaucoup d’autres plateformes,
il sera toutefois nécessaire de créer vous-mêmes
les deux images de base, l’une avec les outils, l’autre avec les
dépendances&nbsp;d’exécution seules. Il sera
alors particulièrement important de respecter les bonnes
pratiques de création des <span class="courier11">Dockerfile</span>,
car ils seront utilisés dans plusieurs images. Le respect
de ces bonnes pratiques permet par exemple, comme ci-dessus, de
partager la même description pour des images Windows et
des images Linux, ainsi même que pour plusieurs plateformes
matérielles, ce qui est très appréciable.</p>
            </div>
          </div>
        </div>
      </div>
      <div class="sect2" id="refTitle19">
        <h2 class="title">7. Arborescence recommandée</h2>
        <div class="sect3" id="refTitle20">
          <h3 class="title">a. Avantage d’une arborescence type</h3>
          <p class="defaut">Lorsqu’une image est compilée à partir
d’un <span class="courier11">Dockerfile</span>, le répertoire
ciblé (par défaut&nbsp;le répertoire
courant) est entièrement recopié au moment de
la compilation, car il correspond à ce qu’on appelle le
contexte (voire plus haut dans le précédent chapitre
pour plus de détails). C’est dans ce contenu que les fonctions <span class="courier11">ADD</span> et <span class="courier11">COPY</span> vont
piocher les fichiers nécessaires à la création
des images, et elles n’ont d’ailleurs pas la possibilité d’aller
chercher d’autres fichiers sur un répertoire arbitraire
du système de fichiers.</p>
          <p class="defaut">Ceci induit un mode de stockage des fichiers
nécessaires à la création d’une image
qui est assez standard, à savoir un répertoire
contenant la totalité de ce qui sera nécessaire à la
compilation, avec le <span class="courier11">Dockerfile</span> au
premier niveau de ce répertoire. Il est également
courant de mettre en place un fichier d’information ainsi qu’un
fichier de licence&nbsp;si nécessaire au même
endroit.</p>
          <p class="defaut">Le lien avec le développement logiciel
est très fort, car Docker est souvent utilisé pour
le déploiement d’applications après qu’elles ont été compilées.
Nous reviendrons plus en détail dans un chapitre suivant
sur tous les apports de Docker à l’ALM (<span class="italic">Application Lifecycle Management</span>,
c’est-à-dire la gestion du cycle de vie d’un programme
informatique, de sa compilation à sa maintenance), et en
particulier à l’intégration continue, mais cette
section sur la structure arborescente des projets Docker ne peut
pas être abordée sans expliquer que cette structure
est intimement liée à celle du code source.</p>
          <p class="defaut">Si on prend l’exemple d’un projet issu de
GitHub, il existe là aussi une structure standard, avec
un fichier <span class="courier11">README.md</span> (format MarkDown) à la
racine, ainsi que le fichier <span class="courier11">.gitignore</span> et
l’éventuel fichier <span class="courier11">LICENSE.md</span>.
Une bonne pratique est de fusionner le répertoire contenant
le <span class="courier11">Dockerfile</span> avec celui contenant
le projet qui va servir à fournir les livrables qui seront
intégrés dans l’image Docker lors de la compilation.</p>
          <p class="defaut">Cette arborescence "type" est, de manière
réduite, la suivante&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP78.png" title="images/04EP78.png" src="IMAGES/04EP78.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Les avantages de ce stockage dans un seul
répertoire sont nombreux. Tout d’abord, la compilation
est complètement autonome et le <span class="courier11">Dockerfile</span> n’a besoin
d’aucune autre référence que ce qui se trouve
dans le répertoire courant, ce qui facilite son déplacement.&nbsp;En
plus, comme la gestion de code source travaille généralement
sur des projets qui sont contenus également dans un seul répertoire,
il est relativement aisé de faire en sorte que l’ALM réalise
la compilation du code puis la génération de l’image
dans un même script, facilitant ainsi la gestion de versions.
Enfin, cela rend simple d’inclure le <span class="courier11">Dockerfile</span> directement
dans le dépôt GitHub, et ainsi de le gérer
exactement comme s’il s’agissait d’un fichier de code source.</p>
          <p class="defaut">Dans les approches de déploiement
actuelles où on cherche à créer rapidement des
instances de serveurs immutables, la capacité non seulement
de tracer tout l’historique, mais également de pouvoir
recréer un serveur exactement comme il se trouvait dans
telle ou telle version ou à une date précise est
grandement facilitée par le fait de garder tout le nécessaire
pour la construction de l’image dans un seul et même dépôt
d’un gestionnaire&nbsp;de code source.</p>
        </div>
        <div class="sect3" id="refTitle21">
          <h3 class="title">b. Intégration des fichiers</h3>
          <p class="defaut">Cette approche est en lien avec la notion
d’Infrastructure As Code, où la gestion&nbsp;de l’infrastructure
de déploiement d’une application logicielle est elle-même écrite
dans un langage proche d’un langage de développement. Ceci
permet une amélioration de la qualité du déploiement,
car l’opération est entièrement automatisée
et ne dépend plus d’étapes manuelles. Les risques
d’erreurs sont réduits, et surtout le temps complet d’installation
d’un environnement est fortement diminué, ce qui permet
de tester plus souvent.</p>
          <p class="defaut">Le mélange entre les deux domaines
est également lié à la notion de DevOps, où les
développeurs et les opérationnels sont appelés à travailler
ensemble de manière beaucoup plus étroite. Traditionnellement,
les développeurs finissaient leur travail, puis fournissaient
les livrables aux opérationnels qui devaient les installer
et les exploiter. Dans une approche DevOps, où le développement
se fait de manière plus continue, l’installation et l’exploitation sont
prévues dès le début et à part
entière comme des étapes du processus de développement.
Il y a donc une continuité totale entre la création
de code source, sa compilation, sa recette par des tests et son
déploiement dans l’environnement cible. Les outils d’intégration
continue ont pour but de faire en sorte que la modification d’un
fichier de code source soit répercutée de manière
automatique dans l’environnement final.</p>
          <p class="defaut">Cette façon de faire induit elle
aussi des bonnes pratiques sur l’écriture des fichiers <span class="courier11">Dockerfile</span>. Par exemple, il est recommandé de
se baser sur la structure de répertoires pour les différentes
commandes de génération de l’image, car elle constitue
une convention partagée. Imaginons le fichier <span class="courier11">Dockerfile</span> ci-dessous&nbsp;:</p>
          <pre class="programlisting"><code class="hljs sql">FROM ubuntu:focal&nbsp;
&nbsp;
RUN apt-get <span class="hljs-keyword">update</span> \&nbsp;
&nbsp;&amp;&amp; apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> -y \&nbsp;
&nbsp; &nbsp;python3 \&nbsp;
&nbsp; &nbsp;python3-pip \&nbsp;
&nbsp;&amp;&amp; pip3 <span class="hljs-keyword">install</span> Flask<b>&nbsp;
&nbsp;
COPY src/webtest.py webtest.py&nbsp;
COPY src/mathapi.py mathapi.py&nbsp;
COPY src/math.py math.py</b>&nbsp;
&nbsp;
EXPOSE <span class="hljs-number">5000</span>&nbsp;
ENTRYPOINT [<span class="hljs-string">"python3"</span>]&nbsp;
CMD [<span class="hljs-string">"webtest.py"</span>]</code></pre>
          <p class="defaut">Si un développeur rajoute un fichier
de code source dans la solution, il faudra également modifier
le fichier <span class="courier11">Dockerfile</span>. Si la modification
est oubliée, il se peut que l’application fonctionne correctement
sur son poste, mais, au mieux, la fonctionnalité correspondante
sera absente de l’image Docker générée.
L’opérationnel devra alors intervenir&nbsp;pour trouver
pourquoi l’environnement ne fonctionne pas comme attendu, et, son
diagnostic réalisé, il devra ajouter le nouveau
fichier de code source dans le <span class="courier11">Dockerfile</span> ou
demander au développeur de réparer son oubli.</p>
          <p class="defaut">La solution consiste en un <span class="courier11">Dockerfile</span> où on se base
par convention sur l’ensemble du contenu du répertoire <span class="courier11">src</span>. L’ajout d’un fichier source est
alors automatiquement pris en compte, ce qui fluidifie le fonctionnement
DevOps. Le <span class="courier11">Dockerfile</span> est au final
bien plus simple&nbsp;:</p>
          <pre class="programlisting"><code class="hljs sql">FROM ubuntu:focal&nbsp;
&nbsp;
RUN apt-get <span class="hljs-keyword">update</span> \&nbsp;
&nbsp;&amp;&amp; apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> -y \&nbsp;
&nbsp; &nbsp;python3 \&nbsp;
&nbsp; &nbsp;python3-pip \&nbsp;
&nbsp;&amp;&amp; pip3 <span class="hljs-keyword">install</span> Flask<b>&nbsp;
&nbsp;
COPY src/ .</b>&nbsp;
&nbsp;
EXPOSE <span class="hljs-number">5000</span>&nbsp;
ENTRYPOINT [<span class="hljs-string">"python3"</span>]&nbsp;
CMD [<span class="hljs-string">"webtest.py"</span>]</code></pre>
          <p class="defaut">Et surtout, il est inutile de le modifier
lors de l’ajout d’un nouveau fichier.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">On pourrait se poser la question de
ce qui va faire que l’image sera effectivement recompilée,&nbsp;vu
que le fichier ne change pas du tout&nbsp;: tout pourrait en théorie être
repris du cache. Mais comme expliqué plus haut, Docker
invalide correctement le cache à partir du moment où le
contexte fourni pour la copie de l’image a changé. Ceci
veut dire par contre que si seuls des fichiers exclus par le fichier <span class="courier11">.dockerignore</span> sont modifiés
ou ajoutés, alors le mécanisme sera suffisamment
intelligent pour reprendre l’image en cache.</p>
            </div>
          </div>
        </div>
        <div class="sect3" id="refTitle22">
          <h3 class="title">c. Limitation du contexte</h3>
          <p class="defaut">Attention toutefois à ne pas tomber
dans l’excès inverse, de prise en compte indifférenciée
de tout le contenu. Par défaut, la totalité du
contexte est recopiée lors de la compilation de l’image,
ce qui nécessite de bien surveiller le volume du répertoire
contenant le <span class="courier11">Dockerfile</span> et tout
le nécessaire.</p>
          <p class="defaut">Si ce répertoire est fusionné avec
celui d’un projet logiciel, comme nous l’avons recommandé plus
haut, il n’est pas rare que la compilation du code source (pas de
l’image) entraîne la création de nombreux fichiers
temporaires et de logs qui sont inutiles au fonctionnement de l’image.
Il est alors nécessaire de faire le ménage dans
ce qui va être passé dans le contexte.</p>
          <p class="defaut">La méthode la plus élégante
pour ce faire est de mettre en place un fichier <span class="courier11">.dockerignore</span>&nbsp;dans
lequel seront spécifiés tous les patterns correspondant aux
fichiers&nbsp;à ne pas prendre en compte lors de la
compilation, ou plus précisément lors de l’établissement
du contexte.</p>
          <p class="defaut">Un contenu typique serait le suivant&nbsp;:</p>
          <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-class">.dockerignore</span>&nbsp;
<span class="hljs-selector-class">.git</span>&nbsp;
<span class="hljs-selector-class">.gitignore</span>&nbsp;
<span class="hljs-selector-tag">bin</span>&nbsp;
<span class="hljs-selector-tag">logs</span>&nbsp;
*<span class="hljs-selector-class">.log</span></code></pre>
          <p class="defaut">En fonction de la plateforme logicielle utilisée
pour l’application embarquée dans l’image, le fichier contiendra également
des lignes pour exclure les répertoires <span class="courier11">obj</span> (.NET), le répertoire <span class="courier11">node_modules</span> (pour Node),
etc. De nombreux templates existent sur Internet pour ne pas perdre
du temps à rechercher le contenu à exclure de
manière standard sur telle ou telle technologie. Pour ne
prendre qu’un exemple, le fichier&nbsp;proposé sur <a class="url" href="https://github.com/themattrix/python-pypi-template/blob/master/.dockerignore" target="_blank">https://github.com/themattrix/python-pypi-template/blob/master/.dockerignore</a> est un
contenu très complet pour du développement en
Python.</p>
          <p class="defaut">Les symboles <span class="courier11">*</span> et <span class="courier11">?</span> peuvent être utilisés
avec leur signification usuelle de remplacement d’un ensemble quelconque
de caractères ou de n’importe quel caractère unique,
respectivement. La syntaxe complète pour l’exclusion des fichiers
et répertoires est celle de la fonction <span class="courier11">Match</span> du langage Go, dans lequel Docker
est écrit. La référence est donc <a class="url" href="http://golang.org/pkg/path/filepath/#Match" target="_blank">http://golang.org/pkg/path/filepath/#Match</a></p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">À noter qu’il est de bonne
pratique de lister le fichier .<span class="courier11">dockerignore</span> lui-même. Il
semble en effet difficile d’imaginer un cas où il pourrait
servir dans l’image compilée elle-même puisqu’il
contient justement une information permettant de restreindre les
fichiers servant&nbsp;à l’opération de compilation
de cette image.</p>
            </div>
          </div>
        </div>
      </div>
      <div class="sect2" id="refTitle23">
        <h2 class="title">8. La question du processus unique</h2>
        <div class="sect3" id="refTitle24">
          <h3 class="title">a. Principe général</h3>
          <p class="defaut">La philosophie générale
des conteneurs, en particulier dans des architectures de microservices,
est qu’un conteneur doit contenir un et un seul service applicatif.</p>
          <p class="defaut">L’application la plus rigoureuse de ce principe
aboutit à n’autoriser qu’un seul processus dans un conteneur
(il a alors le PID 1). L’avantage de cette approche est la simplicité de
gestion, car le cycle de vie des conteneurs est alors parfaitement
aligné sur les applicatifs.</p>
          <p class="defaut">Un des buts principaux des conteneurs (que
ce soit avec Docker ou en utilisant une autre technologie) est de
réduire le couplage entre les applications et, par exemple,
rendre facile de faire fonctionner sur la même machine
deux applications utilisant des versions différentes d’une
runtime donnée. Le principe même de faire tourner
deux applications dans le même conteneur paraît
donc illogique puisqu’il recrée ce couplage entre celles-ci.</p>
        </div>
        <div class="sect3" id="refTitle25">
          <h3 class="title">b. Exception au principe général avec
Supervisor<var style="display:none"> Supervisor</var></h3>
          <p class="defaut">Comme pour toute règle, il existe
toutefois des exceptions et des cas particuliers dans lesquels ce
couplage peut faire sens, et Docker n’empêche nullement de
multiples processus d’être lancés dans le même
conteneur. Ceci est d’ailleurs fort logique, car l’inverse&nbsp;empêcherait
de fonctionner toute application utilisant la commande <span class="courier11">fork</span>, qui génère
un processus fils du processus courant. Or, nombreuses sont les
applications serveurs qui fonctionnent de cette manière, à commencer
par les serveurs web qui créent des processus de travail, de
façon à pouvoir facilement assurer un fonctionnement
continu même si ces processus s’arrêtent en erreur.</p>
          <p class="defaut">Certains concepteurs d’images ont utilisé cette
approche d’une manière un peu plus discutable pour mettre
en œuvre des images "complètes" contenant par
exemple un CMS (<span class="italic">Content Management Software</span>&nbsp;:
logiciel de gestion de contenus) ainsi que sa base de données
de persistance des articles et autres entités publiées.
On s’éloigne alors de la logique de découplage,
mais il s’agit d’un choix architecturel assumé.</p>
          <p class="defaut">Supervisor est un processus de gestion de
lancement d’autres processus qui permet de mettre en œuvre
facilement ce genre de choses. Imaginons par exemple que nous souhaitions
mettre en œuvre un serveur web Apache ainsi qu’une base
de données PostgreSQL dans la même image. Pour
cela, en plus des commandes d’installation telles que nous les aurions écrites
si nous avions créé deux <span class="courier11">Dockerfile</span> séparés,
nous rajoutons l’opération suivante&nbsp;:</p>
          <pre class="programlisting"><code class="hljs sql">RUN apt-get <span class="hljs-keyword">update</span> &amp;&amp; apt-<span class="hljs-keyword">get</span> -y <span class="hljs-keyword">install</span> supervisor</code></pre>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Bien penser à fusionner cette
installation avec les autres paquetages à installer, pour
ne pas créer des couches d’images inutiles.</p>
            </div>
          </div>
          <p class="defaut">L’étape suivante consiste à créer
un fichier <span class="courier11">supervisord.conf</span>, avec
un contenu tel que ci-dessous&nbsp;:</p>
          <pre class="programlisting"><code class="hljs sql">[supervisord]&nbsp;
nodaemon=true&nbsp;
&nbsp;
[program:pgsql]&nbsp;
command=/usr/local/pgsql/bin/pg_ctl <span class="hljs-keyword">start</span> -l <span class="hljs-keyword">logfile</span> -D&nbsp;
/usr/<span class="hljs-keyword">local</span>/pgsql/<span class="hljs-keyword">data</span>&nbsp;
<span class="hljs-keyword">user</span>=postgres&nbsp;
autorestart=<span class="hljs-literal">true</span>&nbsp;
&nbsp;
[program:apache2]&nbsp;
command=/<span class="hljs-keyword">bin</span>/bash -c <span class="hljs-string">"source /etc/apache2/envvars &amp;&amp; exec&nbsp;
/usr/sbin/apache2 -DFOREGROUND"</span></code></pre>
          <p class="defaut">La première option permet de ne pas
démarrer Supervisor en mode démon, mais en processus
d’avant-plan, ce qui est nécessaire pour Docker, le cycle
de vie d’un conteneur étant lié à celui
du processus principal d’identifiant 1. Ensuite, les sections permettent
de définir les processus à lancer au démarrage. Dans
la première, on donne la commande de lancement de la base
de données PostgreSQL, qui sera lancée sous l’utilisateur <span class="courier11">postgres</span> et redémarrera de manière
automatique si problème. Dans le second,&nbsp;le serveur
Apache est configuré.</p>
          <p class="defaut">Pour que ce fichier soit pris en compte dans
notre image, il faudra bien sûr recopier le fichier du
contexte dans l’image lors de la compilation&nbsp;:</p>
          <pre class="programlisting"><code class="hljs">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</code></pre>
          <p class="defaut">Enfin, l’opération <span class="courier11">CMD</span> devra lancer Supervisor au lieu
d’un seul des processus&nbsp;:</p>
          <pre class="programlisting"><code class="hljs javascript">CMD [<span class="hljs-string">"/usr/bin/supervisord"</span>]</code></pre>
          <p class="defaut">Lorsqu’un conteneur sera lancé à partir
de l’image compilée avec le <span class="courier11">Dockerfile</span> décrit&nbsp;ci-dessus,
les deux processus seront démarrés et les deux
ports exposés si les opérations correspondantes
ont bien été reprises des <span class="courier11">Dockerfile</span> séparés.
Bien sûr, toutes les limitations s’appliquent alors et,
par exemple, la mise en pause du conteneur provoque évidemment
l’indisponibilité des deux applicatifs.</p>
        </div>
        <div class="sect3" id="refTitle26">
          <h3 class="title">c. Critique</h3>
          <p class="defaut">Cette approche est bien sûr critiquable
si la possibilité d’arrêter le serveur web sans
arrêter la base de données est nécessaire.
Si, en plus, la base de données est, comme le serveur web,
en exposition à l’extérieur par son port standard, cela
veut dire que d’autres processus pourront écrire des données
dans PostgreSQL. Du coup, il deviendra encore plus compliqué de
redémarrer le serveur web en coupant l’image, car d’autres
images en dépendront nécessairement. Si au moins
la base de données est limitée&nbsp;en utilisation
interne par l’image, cela permettra d’éviter ce problème.</p>
          <p class="defaut">Une polémique existe quant à l’utilisation
correcte de Supervisor, et certains considèrent son utilisation
comme contraire à l’esprit de Docker, prônant
la présence d’un service unique dans une image.</p>
          <div class="note">
            <div class="remarkimg"><span class="icon-note"></span></div>
            <div class="divinline">
              <p class="remarque">Cette polémique est par ailleurs
polluée par le fait que, lorsque Supervisor est utilisé dans
une image Docker, il se retrouve à prendre le processus
d’identifiant 1 dans l’image. Or, sur une machine physique, ce processus
est associé au programme en charge du démarrage
de tous les services, dit <span class="courier11">init</span>,
et il existe une autre polémique sur la récente
utilisation de <span class="courier11">systemd</span> comme nouvel
outil <span class="courier11">init</span> sur Debian et Ubuntu.
En pratique, les deux sujets n’ont rien à voir.</p>
            </div>
          </div>
          <p class="defaut">La discussion sur ces points semble toutefois
close au moment de l’écriture de la présente édition,
et Supervisor n’est en pratique que très peu utilisé.
Usage faisant loi, les bonnes pratiques sont désormais
assez solidement établies sur un processus unique dans
un conteneur.</p>
          <p class="defaut">Le cas précédemment cité de
la nécessité d’un serveur SSH pour pouvoir
accéder au contenu du conteneur est désormais
réglé par le fait qu’il s’agit
d’une mauvaise pratique de sécurité&nbsp;;
le comportement d’un conteneur ne doit être observé que
par les ports et volumes qu’il ouvre et les logs qu’il
produit. Pour ce qui est des rares cas où un processus
annexe doit être lancé temporairement (par exemple
un programme de sauvegarde ou de diagnostic), la commande <span class="courier11">docker exec</span> est suffisante, et elle
sécurise&nbsp;bien l’ensemble car elle ne
peut être lancée que par une personne ayant accès
au démon Docker qui supporte le conteneur.</p>
        </div>
        <div class="sect3" id="refTitle27">
          <h3 class="title">d. Approche intermédiaire</h3>
          <p class="defaut">Au-delà de cette polémique
et de la possibilité de lancer ponctuellement des processus
additionnels, il peut faire sens dans certains cas précis
d’avoir un processus primaire qui représente la fonctionnalité principale
de l’image et qui se trouve accompagné de processus esclaves
ou utilitaires permettant au premier de mieux fonctionner.</p>
          <p class="defaut">C’est d’ailleurs en ce sens que Docker publie
la page de documentation sur l’utilisation de Supervisor (<a class="url" href="https://docs.docker.com/articles/using_supervisord/" target="_blank">https://docs.docker.com/articles/using_supervisord/</a>)
avec un des deux processus qui est le démon SSH, et l’autre
le serveur web Apache. Des cas particuliers, bien sûr non
acceptables en production mais toutefois existants, peuvent justifier
une image dont le processus "principal" serait Apache Web Server,
mais qui souhaiterait laisser un administrateur se connecter au
conteneur. Le démon SSH est alors un processus secondaire.
Du point de vue technique, le processus principal (de PID 1) est
bien Supervisor. Mais la logique est respectée avec un
service principal qui est l’exposition de contenu web. Comme précisé plus
haut, il est essentiel de comprendre en quoi cette manipulation
provoque un problème de sécurité et ne
doit être utilisée que lors des phases de développement
et de tests.</p>
          <p class="defaut">Une autre marque de la reconnaissance officielle
de ce mode de fonctionnement par Docker est l’apparition de la commande <span class="courier11">exec</span>, citée plus haut et
qui permet de démarrer un processus dans un conteneur déjà lancé.
Cette commande est particulièrement utile pour superviser
un conteneur de manière introspective (par exemple, réaliser
un <span class="courier11">tail</span> sur un fichier de log),
ce qui, encore une fois, constitue bien une activité secondaire
et ne contrevient donc pas à l’esprit de service unique
du conteneur. Bien sûr, il serait encore plus propre de faire
en sorte que le conteneur exporte tous les messages nécessaires à sa
supervision depuis l’extérieur, mais l’exécution
d’un processus de contrôle, en phase de mise au point,
n’a rien de scandaleux.</p>
          <p class="defaut">À titre purement documentaire, voici
un exemple d’utilisation de la commande <span class="courier11">docker&nbsp;exec</span> pour récupérer
une sauvegarde d’une base de données MongoDB&nbsp;:</p>
          <div class="image">
            <div class="mediaobject"><img class="imagedata picturebox" alt="images/04EP79.png" title="images/04EP79.png" src="IMAGES/04EP79.png?id=AAEAAAD%2f%2f%2f%2f%2fAQAAAAAAAAAMAgAAAE1FbmkuRWRpdGlvbnMuTWVkaWFwbHVzLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbAUBAAAAJ0VuaS5FZGl0aW9ucy5NZWRpYXBsdXMuQ29tbW9uLldhdGVybWFyawIAAAAHcGlzVGV4dAlwaWR0ZURhdGUBAA0CAAAABgMAAAAyTGF2b2NvIEVuem8gLSBiNGFhNGUzYy01ODBkLTQyNWQtOWMwOC1mNDBjMjRlNTY0ZmNtW4SLy7jYiAs%3d"></div>
          </div>
          <p class="defaut">Pour finir sur ce point quasi philosophique,
Phusion donne une bonne explication (sur <a class="url" href="https://github.com/phusion/baseimage-docker#wait-i-thought-docker-is-about-running-a-single-process-in-a-container" target="_blank">https://github.com/phusion/baseimage-docker#wait-i-thought-docker-is-about-running-a-single-process-in-a-container</a>)
du fait que plusieurs processus ne veulent pas nécessairement
dire qu’on perd de vue l’aspect monoservice d’un conteneur.</p>
        </div>
      </div>
    </div></div></div></div></app-page-content><!----><!----><!----></div></kendo-pdf-export>