<kendo-pdf-export _ngcontent-uvf-c168="" papersize="A4" margin="2cm" id="div-book-content" class="col-12 col-sm-10 offset-0 div-book-content" uipath_custom_id="10"><div><app-page-content _ngcontent-uvf-c168="" _nghost-uvf-c166="" class="font-size-14 font-size-sm-20"><div _ngcontent-uvf-c166="" class="mainContent mt-4"><div _ngcontent-uvf-c166="" id="bookContent" class="bookContent"><div _ngcontent-uvf-c166="" id="content"><div class="sect1" style="abcpdf-tag-visible: true" id="AU_071e1b83-eff8-4320-957f-e841d8a0b67e" uri="ImagesUri_../download/5c180f28-f752-47db-98e8-8656c84b148d/images/">
      <h1 class="title">Création manuelle d’une nouvelle image</h1>
      <div class="sect2" id="refTitle0">
        <h2 class="title">1. Objectif </h2>
        <p class="defaut">Dans le chapitre précédent,
nous avons étudié le fonctionnement de base de Docker
en utilisant des images préparées à l’avance
pour nos exemples&nbsp;: l’image <span class="courier11">hello-world</span>&nbsp;pour
les premiers tests, l’image <span class="courier11">ubuntu</span> pour
les approches interactives par la ligne de commande, et enfin l’image <span class="courier11">nginx</span> pour les tests impliquant un
processus serveur. Ces images ont été récupérées
en ligne sur le registre Docker Hub.</p>
        <p class="defaut">Bien que cette façon de fonctionner
puisse suffire à des mises en œuvre extrêmement
simples, un moment survient où il devient nécessaire
de créer ses propres images pour évoluer vers
plus de complexité. C’est ce type de manipulation que nous
allons illustrer dans le présent chapitre.</p>
      </div>
      <div class="sect2" id="refTitle1">
        <h2 class="title">2. Approche</h2>
        <p class="defaut">L’approche naïve pour créer
sa propre image est d’utiliser la commande <span class="courier11">commit</span> entrevu&nbsp; dans
le chapitre précédent pour persister l’état
d’un conteneur sous forme d’une nouvelle image, après avoir
ajouté à celui-ci les modifications nécessaires.
Pour cela, nous pourrions lancer par exemple un conteneur sur une
image <span class="courier11">ubuntu</span> comme base et installer
un produit en ligne de commande dans le conteneur.</p>
        <p class="defaut">Ensuite, le conteneur obtenu serait sauvegardé sous
forme d’une image qu’il serait possible d’instancier ensuite autant
de fois que souhaité. Bref, nous aurions créé une
image avec un processus intégré selon nos besoins.</p>
      </div>
      <div class="sect2" id="refTitle2">
        <h2 class="title">3. Difficultés</h2>
        <p class="defaut">Dans les précédentes éditions
du présent ouvrage, cette méthode était
montrée en détail,&nbsp;de façon à faire
apparaître toutes les difficultés liées&nbsp;:</p>
        <div class="divliste1">
          <ul class="liste1">
            <li class="liste1">
              <p class="liste1">Taille de l’image,
car les modifications, même d’effacement, s’empilent dans les
couches et les effets d’une installation manuelle, avec des étapes
de compilation et des productions de fichiers temporaires, peuvent être
importants.</p>
            </li>
            <li class="liste1">
              <p class="liste1">Difficulté de changer le
processus à démarrer lors du lancement d’un conteneur,
car par défaut c’est celui de l’image de base qui se lance.</p>
            </li>
            <li class="liste1">
              <p class="liste1">Besoin d’une réelle expertise
sur le paramétrage de l’application, de façon à l’installer
de manière optimale et surtout suffisamment souple pour
qu’un lancement de conteneur permette de faire varier certains des
paramètres.</p>
            </li>
            <li class="liste1">
              <p class="liste1">Problématique de sécurité à gérer,
en particulier lié au fait d’utiliser un utilisateur avec
des droits élevés dans l’image.</p>
            </li>
            <li class="liste1">
              <p class="liste1">Complexité de gestion du
cycle de vie si l’image de base est faite pour fonctionner en mode
interactif et que nous souhaitons mettre en œuvre un serveur,
fait pour fonctionner en mode démon, en arrière-plan.</p>
            </li>
          </ul>
        </div>
      </div>
      <div class="sect2" id="refTitle3">
        <h2 class="title">4. Conclusion</h2>
        <p class="defaut">La mise en œuvre d’une image propre
par cette méthode est extrêmement complexe. De
plus, dans les nouvelles versions des images de base, plus restreintes
pour des raisons d’efficacité, certaines dépendances
nécessaires au déploiement d’une application serveur
doivent elles-mêmes être installées au préalable,
y compris des fonctionnalités de niveau système
qui nécessitent pour elles également une compétence
développée.</p>
        <p class="defaut">Comme on l’aura compris, il est fortement
recommandé de faire réaliser cette opération
de construction d’une image par une personne experte de l’application
ciblée, de façon à obtenir une image
propre. Or, cette mise en œuvre propre existe certainement
déjà, sous la forme d’une image Docker officielle. De
plus, les personnes en charge de cette image nous offrent la "recette
utilisée" sous la forme d’un fichier contenant toutes les
commandes nécessaires à une installation parfaite.
Pourquoi faire autrement&nbsp;?</p>
      </div>
    </div></div></div></div></app-page-content><!----><!----><!----></div></kendo-pdf-export>